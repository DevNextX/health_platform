/**
 * Time Synchronization Utilities
 * Generated by Copilot
 */

const TIME_SYNC_KEY = 'time_sync_data';
const TIME_DISCREPANCY_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds

/**
 * Get server time and calculate the discrepancy with client time
 * @returns {Promise<{serverTime: Date, clientTime: Date, discrepancy: number, hasDiscrepancy: boolean}>}
 */
export const checkTimeDiscrepancy = async () => {
  try {
    const clientTimeBeforeRequest = new Date();
    
    // Make a direct axios call to avoid auth interceptor issues
    const response = await fetch('/api/v1/auth/server-time');
    const data = await response.json();
    
    const clientTimeAfterRequest = new Date();
    const serverTime = new Date(data.server_time);
    
    // Use average of before/after request times to account for network latency
    const clientTime = new Date((clientTimeBeforeRequest.getTime() + clientTimeAfterRequest.getTime()) / 2);
    
    const discrepancy = Math.abs(serverTime.getTime() - clientTime.getTime());
    const hasDiscrepancy = discrepancy > TIME_DISCREPANCY_THRESHOLD;
    
    const syncData = {
      serverTime,
      clientTime,
      discrepancy,
      hasDiscrepancy,
      lastChecked: new Date(),
      networkLatency: clientTimeAfterRequest.getTime() - clientTimeBeforeRequest.getTime()
    };
    
    // Store the sync data for later reference
    localStorage.setItem(TIME_SYNC_KEY, JSON.stringify({
      ...syncData,
      serverTime: syncData.serverTime.toISOString(),
      clientTime: syncData.clientTime.toISOString(),
      lastChecked: syncData.lastChecked.toISOString()
    }));
    
    return syncData;
  } catch (error) {
    console.error('Failed to check time discrepancy:', error);
    return {
      serverTime: null,
      clientTime: new Date(),
      discrepancy: 0,
      hasDiscrepancy: false,
      error: error.message
    };
  }
};

/**
 * Get stored time sync data
 * @returns {Object|null}
 */
export const getStoredTimeSyncData = () => {
  try {
    const stored = localStorage.getItem(TIME_SYNC_KEY);
    if (!stored) return null;
    
    const data = JSON.parse(stored);
    return {
      ...data,
      serverTime: new Date(data.serverTime),
      clientTime: new Date(data.clientTime),
      lastChecked: new Date(data.lastChecked)
    };
  } catch (error) {
    console.error('Failed to parse stored time sync data:', error);
    return null;
  }
};

/**
 * Format time discrepancy for user display
 * @param {number} discrepancy - Discrepancy in milliseconds
 * @returns {string}
 */
export const formatTimeDiscrepancy = (discrepancy) => {
  const minutes = Math.floor(discrepancy / (60 * 1000));
  const seconds = Math.floor((discrepancy % (60 * 1000)) / 1000);
  
  if (minutes > 0) {
    return `${minutes} minute${minutes !== 1 ? 's' : ''} ${seconds} second${seconds !== 1 ? 's' : ''}`;
  }
  return `${seconds} second${seconds !== 1 ? 's' : ''}`;
};

/**
 * Clear stored time sync data
 */
export const clearTimeSyncData = () => {
  localStorage.removeItem(TIME_SYNC_KEY);
};

/**
 * Check if we need to recheck time sync (every 30 minutes)
 * @returns {boolean}
 */
export const shouldRecheckTimeSync = () => {
  const stored = getStoredTimeSyncData();
  if (!stored) return true;
  
  const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
  return stored.lastChecked < thirtyMinutesAgo;
};