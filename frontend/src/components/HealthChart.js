/**
 * Health Chart Component using ECharts
 * Generated by Zhuang
 */
import React, { useEffect, useState, useCallback } from 'react';
import ReactEChartsCore from 'echarts-for-react/lib/core';
import * as echarts from 'echarts/core';
import { LineChart } from 'echarts/charts';
import {
  GridComponent,
  TooltipComponent,
  LegendComponent,
  DataZoomComponent,
} from 'echarts/components';
import { CanvasRenderer } from 'echarts/renderers';
import { Empty, Select, Space, Button } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import dayjs from 'dayjs';
import { useTranslation } from 'react-i18next';
import { parseServerTime } from '../utils/date';
import { useThresholds } from '../context/ThresholdContext';

const { Option } = Select;

const SYSTOLIC_COLOR = '#1890ff';
const DIASTOLIC_COLOR = '#52c41a';
const HEART_RATE_COLOR = '#722ed1';
const WARNING_COLOR = '#ff4d4f';
const BORDERLINE_COLOR = '#faad14';
const DEFAULT_SYMBOL_SIZE = 6;
const HIGHLIGHT_SYMBOL_SIZE = 9;

// Register ECharts components
echarts.use([
  LineChart,
  GridComponent,
  TooltipComponent,
  LegendComponent,
  DataZoomComponent,
  CanvasRenderer,
]);

const HealthChart = ({ records = [] }) => {
  const { t } = useTranslation();
  const { classifyRecord } = useThresholds();
  const [timeRange, setTimeRange] = useState('week'); // week, month, all
  const [filteredRecords, setFilteredRecords] = useState([]);

  const filterRecordsByTimeRange = useCallback(() => {
    if (!records.length) {
      setFilteredRecords([]);
      return;
    }

    let filtered = [...records];
    const now = dayjs();

    switch (timeRange) {
      case 'week':
        filtered = records.filter(record => 
          parseServerTime(record.timestamp).isAfter(now.subtract(7, 'day'))
        );
        break;
      case 'month':
        filtered = records.filter(record => 
          parseServerTime(record.timestamp).isAfter(now.subtract(30, 'day'))
        );
        break;
      default:
        // 'all' - use all records
        break;
    }

    // Sort by timestamp
    filtered.sort((a, b) => parseServerTime(a.timestamp).valueOf() - parseServerTime(b.timestamp).valueOf());
    setFilteredRecords(filtered);
  }, [records, timeRange]);

  useEffect(() => {
    filterRecordsByTimeRange();
  }, [filterRecordsByTimeRange]);

  const downloadChart = () => {
    const chartInstance = document.querySelector('.health-chart canvas');
    if (chartInstance) {
      const link = document.createElement('a');
      link.download = `health-chart-${timeRange}-${dayjs().format('YYYY-MM-DD')}.png`;
      link.href = chartInstance.toDataURL();
      link.click();
    }
  };

  if (!filteredRecords.length) {
    return (
      <div>
        <Space style={{ marginBottom: 16 }}>
          <Select value={timeRange} onChange={setTimeRange} style={{ width: 120 }}>
      <Option value="week">{t('chart.range.week')}</Option>
      <Option value="month">{t('chart.range.month')}</Option>
      <Option value="all">{t('chart.range.all')}</Option>
          </Select>
        </Space>
    <Empty description={t('chart.noData')} />
      </div>
    );
  }

  // Prepare data for ECharts
  const timeAxis = filteredRecords.map(record => 
    parseServerTime(record.timestamp).format('MM-DD HH:mm')
  );
  
  // Backend fields are `systolic` and `diastolic`; coerce to numbers, use nulls for missing values
  const toNumOrNull = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };
  const systolicData = filteredRecords.map(record => toNumOrNull(record.systolic));
  const diastolicData = filteredRecords.map(record => toNumOrNull(record.diastolic));
  const heartRateData = filteredRecords.map(record => toNumOrNull(record.heart_rate));

  // Classify records using dynamic thresholds from context
  const statusMap = filteredRecords.map((record, index) => {
    const systolicValue = systolicData[index];
    const diastolicValue = diastolicData[index];
    const hrValue = heartRateData[index];
    if (systolicValue === null || diastolicValue === null) {
      return 'unknown';
    }
    return classifyRecord(systolicValue, diastolicValue, hrValue);
  });

  const getColorForStatus = (status) => {
    if (status === 'abnormal') return WARNING_COLOR;
    if (status === 'borderline') return BORDERLINE_COLOR;
    return null;
  };

  const systolicSeriesData = systolicData.map((value, index) => {
    if (value === null) {
      return value;
    }
    const status = statusMap[index];
    const color = getColorForStatus(status);
    if (!color) {
      return value;
    }
    return {
      value,
      itemStyle: { color },
      symbolSize: HIGHLIGHT_SYMBOL_SIZE,
    };
  });

  const diastolicSeriesData = diastolicData.map((value, index) => {
    if (value === null) {
      return value;
    }
    const status = statusMap[index];
    const color = getColorForStatus(status);
    if (!color) {
      return value;
    }
    return {
      value,
      itemStyle: { color },
      symbolSize: HIGHLIGHT_SYMBOL_SIZE,
    };
  });

  const numericValues = [...systolicData, ...diastolicData, ...heartRateData]
    .filter((v) => typeof v === 'number');
  let yMin = 0;
  let yMax = 200;
  if (numericValues.length) {
    const minVal = Math.min(...numericValues);
    const maxVal = Math.max(...numericValues);
    const span = maxVal - minVal;
    const paddingBase = span === 0 ? Math.max(5, Math.round((maxVal || 0) * 0.1)) : Math.round(span * 0.1);
    const padding = Math.max(5, paddingBase);
    const candidateMin = Math.max(0, minVal - padding);
    const candidateMax = maxVal + padding;
    yMin = Math.floor(candidateMin / 5) * 5;
    yMax = Math.ceil(candidateMax / 5) * 5;
    if (yMin === yMax) {
      yMax = yMin + 10;
    }
  }

  const option = {
    title: {
  text: t('dashboard.chartTitle'),
      left: 'center',
    },
  tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross',
      },
      formatter: function (params) {
        let result = `${params[0].axisValue}<br/>`;
        params.forEach(param => {
          if (param.value !== null) {
      const unit = param.seriesName === t('chart.series.hr') ? ' bpm' : ' mmHg';
      result += `${param.seriesName}: ${param.value}${unit}<br/>`;
          }
        });
        return result;
      },
    },
    legend: {
      data: [t('chart.series.systolic'), t('chart.series.diastolic'), t('chart.series.hr')],
      top: 30,
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '10%',
      top: '15%',
      containLabel: true,
    },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: timeAxis,
      axisLabel: {
        rotate: 45,
      },
    },
    yAxis: {
      type: 'value',
      name: t('chart.yaxis.unified'),
      position: 'left',
      axisLabel: {
        formatter: (val) => val,
      },
      min: yMin,
      max: yMax,
      nameGap: 45,
    },
    series: [
      {
  name: t('chart.series.systolic'),
        type: 'line',
        data: systolicSeriesData,
        itemStyle: {
          color: SYSTOLIC_COLOR,
        },
        lineStyle: {
          color: SYSTOLIC_COLOR,
        },
        connectNulls: false,
        symbol: 'circle',
        symbolSize: DEFAULT_SYMBOL_SIZE,
        emphasis: {
          itemStyle: {
            borderColor: SYSTOLIC_COLOR,
            borderWidth: 2,
          },
        },
      },
      {
  name: t('chart.series.diastolic'),
        type: 'line',
        data: diastolicSeriesData,
        itemStyle: {
          color: DIASTOLIC_COLOR,
        },
        lineStyle: {
          color: DIASTOLIC_COLOR,
        },
        connectNulls: false,
        symbol: 'circle',
        symbolSize: DEFAULT_SYMBOL_SIZE,
        emphasis: {
          itemStyle: {
            borderColor: DIASTOLIC_COLOR,
            borderWidth: 2,
          },
        },
      },
      {
  name: t('chart.series.hr'),
        type: 'line',
        data: heartRateData,
        itemStyle: {
          color: HEART_RATE_COLOR,
        },
        lineStyle: {
          color: HEART_RATE_COLOR,
        },
        connectNulls: false,
        symbol: 'triangle',
        symbolSize: DEFAULT_SYMBOL_SIZE,
        emphasis: {
          itemStyle: {
            borderColor: HEART_RATE_COLOR,
            borderWidth: 2,
          },
        },
      },
    ],
    dataZoom: [
      {
        type: 'inside',
        start: 0,
        end: 100,
      },
      {
        start: 0,
        end: 100,
      },
    ],
  };

  return (
    <div>
      <Space style={{ marginBottom: 16, justifyContent: 'space-between', width: '100%' }}>
        <Select value={timeRange} onChange={setTimeRange} style={{ width: 120 }}>
          <Option value="week">{t('chart.range.week')}</Option>
          <Option value="month">{t('chart.range.month')}</Option>
          <Option value="all">{t('chart.range.all')}</Option>
        </Select>
        <Button 
          icon={<DownloadOutlined />} 
          onClick={downloadChart}
          type="default"
        >
          {t('chart.download')}
        </Button>
      </Space>
      
      <ReactEChartsCore
        echarts={echarts}
        option={option}
        style={{ height: '400px', width: '100%' }}
        className="health-chart"
      />
    </div>
  );
};

export default HealthChart;
