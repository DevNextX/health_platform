"""
Test cases for admin functionality and role-based access control.
Generated by Copilot
"""
import json
import pytest
from src.models import User
from src.manager.user_manager import UserManager
from src.utils.admin_init import init_super_admin


class TestAdminSystem:
    """Test admin initialization and role management"""
    
    def test_super_admin_initialization(self, app):
        """Test super admin can be initialized"""
        with app.app_context():
            # Initialize super admin
            super_admin = init_super_admin("testadmin", "admin@test.com", "Admin123")
            
            assert super_admin is not None
            assert super_admin.role == "SUPER_ADMIN"
            assert super_admin.must_change_password is True
            assert super_admin.username == "testadmin"
            assert super_admin.email == "admin@test.com"
    
    def test_super_admin_uniqueness(self, app):
        """Test only one super admin can exist"""
        with app.app_context():
            # Create first super admin
            super_admin1 = init_super_admin("admin1", "admin1@test.com", "Admin123")
            assert super_admin1.role == "SUPER_ADMIN"
            
            # Attempt to create second super admin should return existing one
            super_admin2 = init_super_admin("admin2", "admin2@test.com", "Admin123")
            assert super_admin2.id == super_admin1.id  # Same user returned
            
            # Verify only one super admin exists in database
            super_admin_count = User.query.filter_by(role="SUPER_ADMIN").count()
            assert super_admin_count == 1


class TestUserManager:
    """Test enhanced user manager functionality"""
    
    def test_case_insensitive_user_creation(self, app):
        """Test username and email are case insensitive"""
        with app.app_context():
            user_manager = UserManager()
            
            # Create user with mixed case
            user1 = user_manager.create_user("TestUser", "Test@Example.Com", "Password123")
            assert user1.username == "testuser"  # Lowercase
            assert user1.email == "test@example.com"  # Lowercase
    
    def test_case_insensitive_login(self, app):
        """Test login is case insensitive"""
        with app.app_context():
            user_manager = UserManager()
            
            # Create user
            user = user_manager.create_user("testuser", "test@example.com", "Password123")
            
            # Test case insensitive username lookup
            found_user = user_manager.get_user_by_username_or_email("TestUser")
            assert found_user.id == user.id
            
            # Test case insensitive email lookup
            found_user = user_manager.get_user_by_username_or_email("TEST@Example.COM")
            assert found_user.id == user.id
    
    def test_password_strength_validation(self, app):
        """Test password strength validation"""
        with app.app_context():
            user_manager = UserManager()
            
            # Test weak passwords
            assert not user_manager._validate_password_strength("short")
            assert not user_manager._validate_password_strength("12345678")  # Numbers only
            assert not user_manager._validate_password_strength("abcdefgh")  # Letters only
            
            # Test strong passwords
            assert user_manager._validate_password_strength("Password1")
            assert user_manager._validate_password_strength("abc123def")
    
    def test_temporary_password_generation(self, app):
        """Test temporary password generation"""
        with app.app_context():
            user_manager = UserManager()
            
            # Generate multiple passwords to test randomness and requirements
            passwords = [user_manager._generate_temp_password() for _ in range(10)]
            
            for pwd in passwords:
                assert len(pwd) == 8
                assert any(c.isalpha() for c in pwd)  # Has letter
                assert any(c.isdigit() for c in pwd)  # Has digit
            
            # Check they're different (very unlikely to be same if random)
            assert len(set(passwords)) > 1
    
    def test_user_list_filtering(self, app):
        """Test user listing with role filtering"""
        with app.app_context():
            user_manager = UserManager()
            
            # Create users with different roles
            user1 = user_manager.create_user("user1", "user1@test.com", "Pass123", role="USER")
            user2 = user_manager.create_user("admin1", "admin1@test.com", "Pass123", role="ADMIN") 
            super_admin = init_super_admin("superadmin", "super@test.com", "Pass123")
            
            # Test admin view (should exclude super admin)
            result = user_manager.list_users(exclude_roles=["SUPER_ADMIN"])
            user_ids = [u["id"] for u in result["users"]]
            assert user1.id in user_ids
            assert user2.id in user_ids
            assert super_admin.id not in user_ids
            
            # Test super admin view (should include all)
            result = user_manager.list_users()
            user_ids = [u["id"] for u in result["users"]]
            assert user1.id in user_ids
            assert user2.id in user_ids
            assert super_admin.id in user_ids


class TestAdminAPI:
    """Test admin API endpoints"""
    
    @pytest.fixture
    def setup_admin_users(self, app, client):
        """Setup users with different roles for testing"""
        with app.app_context():
            user_manager = UserManager()
            
            # Create test users
            self.regular_user = user_manager.create_user("user", "user@test.com", "Pass123", role="USER")
            self.admin_user = user_manager.create_user("admin", "admin@test.com", "Pass123", role="ADMIN")
            self.super_admin = init_super_admin("superadmin", "super@test.com", "Pass123")
            
            # Get tokens for each user type
            self.user_token = self._get_token(client, "user@test.com", "Pass123")
            self.admin_token = self._get_token(client, "admin@test.com", "Pass123")
            self.super_admin_token = self._get_token(client, "super@test.com", "Pass123")
    
    def _get_token(self, client, email, password):
        """Helper to get JWT token"""
        response = client.post("/api/v1/auth/login", 
                             json={"email": email, "password": password})
        return response.json["access_token"]
    
    def test_admin_user_list_permissions(self, client, setup_admin_users):
        """Test user list endpoint permissions"""
        # Regular user should get 403
        response = client.get("/api/v1/admin/users", 
                            headers={"Authorization": f"Bearer {self.user_token}"})
        assert response.status_code == 403
        
        # Admin should succeed but not see super admin
        response = client.get("/api/v1/admin/users",
                            headers={"Authorization": f"Bearer {self.admin_token}"})
        assert response.status_code == 200
        user_ids = [u["id"] for u in response.json["users"]]
        assert self.regular_user.id in user_ids
        assert self.admin_user.id in user_ids
        assert self.super_admin.id not in user_ids
        
        # Super admin should see all users
        response = client.get("/api/v1/admin/users",
                            headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 200
        user_ids = [u["id"] for u in response.json["users"]]
        assert self.regular_user.id in user_ids
        assert self.admin_user.id in user_ids
        assert self.super_admin.id in user_ids
    
    def test_role_change_permissions(self, client, setup_admin_users):
        """Test role change endpoint permissions"""
        # Regular user should get 403
        response = client.put(f"/api/v1/admin/users/{self.regular_user.id}/role",
                            json={"role": "ADMIN"},
                            headers={"Authorization": f"Bearer {self.user_token}"})
        assert response.status_code == 403
        
        # Admin should get 403 (only super admin can change roles)
        response = client.put(f"/api/v1/admin/users/{self.regular_user.id}/role",
                            json={"role": "ADMIN"}, 
                            headers={"Authorization": f"Bearer {self.admin_token}"})
        assert response.status_code == 403
        
        # Super admin should succeed
        response = client.put(f"/api/v1/admin/users/{self.regular_user.id}/role",
                            json={"role": "ADMIN"},
                            headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 200
        assert response.json["role"] == "ADMIN"
    
    def test_role_change_protection(self, client, setup_admin_users):
        """Test super admin protection rules"""
        # Cannot change super admin role
        response = client.put(f"/api/v1/admin/users/{self.super_admin.id}/role",
                            json={"role": "ADMIN"},
                            headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 400
        assert "super admin" in response.json["message"].lower()
        
        # Cannot create new super admin
        response = client.put(f"/api/v1/admin/users/{self.regular_user.id}/role", 
                            json={"role": "SUPER_ADMIN"},
                            headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 400
        assert "additional super admin" in response.json["message"].lower()
        
        # Cannot change own role
        response = client.put(f"/api/v1/admin/users/{self.super_admin.id}/role",
                            json={"role": "ADMIN"},
                            headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code in [400, 403]  # Either protection rule triggers
    
    def test_password_reset_permissions(self, client, setup_admin_users):
        """Test password reset permissions"""
        # Regular user cannot reset passwords
        response = client.post(f"/api/v1/admin/users/{self.regular_user.id}/password/reset",
                             headers={"Authorization": f"Bearer {self.user_token}"})
        assert response.status_code == 403
        
        # Admin can reset regular user and other admin passwords
        response = client.post(f"/api/v1/admin/users/{self.regular_user.id}/password/reset",
                             headers={"Authorization": f"Bearer {self.admin_token}"})
        assert response.status_code == 200
        assert "temporary_password" in response.json
        assert len(response.json["temporary_password"]) == 8
        
        # Super admin can reset regular and admin passwords  
        response = client.post(f"/api/v1/admin/users/{self.admin_user.id}/password/reset",
                             headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 200
        assert "temporary_password" in response.json
        
        # Cannot reset super admin password
        response = client.post(f"/api/v1/admin/users/{self.super_admin.id}/password/reset",
                             headers={"Authorization": f"Bearer {self.super_admin_token}"})
        assert response.status_code == 403


class TestPasswordManagement:
    """Test password change and force change functionality"""
    
    def test_change_password_success(self, client, app):
        """Test successful password change"""
        with app.app_context():
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "OldPass123")
            
            # Login to get token
            response = client.post("/api/v1/auth/login",
                                 json={"email": "test@test.com", "password": "OldPass123"})
            token = response.json["access_token"]
            
            # Change password
            response = client.post("/api/v1/auth/change-password",
                                 json={"old_password": "OldPass123", "new_password": "NewPass456"},
                                 headers={"Authorization": f"Bearer {token}"})
            assert response.status_code == 200
            assert response.json["must_login_again"] is True
    
    def test_change_password_wrong_old_password(self, client, app):
        """Test password change with wrong old password"""
        with app.app_context():
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "OldPass123")
            
            # Login to get token
            response = client.post("/api/v1/auth/login",
                                 json={"email": "test@test.com", "password": "OldPass123"})
            token = response.json["access_token"]
            
            # Try to change with wrong old password
            response = client.post("/api/v1/auth/change-password",
                                 json={"old_password": "WrongPass", "new_password": "NewPass456"},
                                 headers={"Authorization": f"Bearer {token}"})
            assert response.status_code == 401
    
    def test_force_password_change(self, client, app):
        """Test force password change flow"""
        with app.app_context():
            from src.extensions import db
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "OldPass123")
            user.must_change_password = True
            db.session.commit()
            
            # Login to get token  
            response = client.post("/api/v1/auth/login",
                                 json={"email": "test@test.com", "password": "OldPass123"})
            token = response.json["access_token"]
            
            # Force change password
            response = client.post("/api/v1/auth/force-change-password",
                                 json={"new_password": "NewPass456"},
                                 headers={"Authorization": f"Bearer {token}"})
            assert response.status_code == 200
            assert response.json["must_login_again"] is True


class TestVersionAPI:
    """Test version API endpoint"""
    
    def test_version_endpoint(self, client):
        """Test version endpoint returns correct format"""
        response = client.get("/api/v1/version")
        assert response.status_code == 200
        assert "version" in response.json
        assert response.json["version"] == "1.0.0"  # From config
    
    def test_version_endpoint_public(self, client):
        """Test version endpoint doesn't require authentication"""
        # Should work without any authorization header
        response = client.get("/api/v1/version")
        assert response.status_code == 200


class TestAuthenticationEnhancements:
    """Test enhanced authentication features"""
    
    def test_login_with_username(self, client, app):
        """Test login works with username"""
        with app.app_context():
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "Pass123")
            
            # Login with username
            response = client.post("/api/v1/auth/login",
                                 json={"username": "testuser", "password": "Pass123"})
            assert response.status_code == 200
            assert "access_token" in response.json
            assert response.json["user"]["username"] == "testuser"
    
    def test_login_case_insensitive(self, client, app):
        """Test login is case insensitive"""
        with app.app_context():
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "Pass123")
            
            # Login with different case
            response = client.post("/api/v1/auth/login",
                                 json={"username": "TestUser", "password": "Pass123"})
            assert response.status_code == 200
            
            response = client.post("/api/v1/auth/login", 
                                 json={"email": "TEST@TEST.COM", "password": "Pass123"})
            assert response.status_code == 200
    
    def test_password_strength_validation_on_register(self, client):
        """Test password strength validation during registration"""
        # Test weak password
        response = client.post("/api/v1/auth/register",
                             json={"username": "test", "email": "test@test.com", "password": "weak"})
        assert response.status_code == 400
        assert "PASSWORD_TOO_WEAK" in response.json.get("error_data", {}).get("code", "")
        
        # Test strong password
        response = client.post("/api/v1/auth/register", 
                             json={"username": "test", "email": "test@test.com", "password": "StrongPass123"})
        assert response.status_code == 201
    
    def test_must_change_password_enforcement(self, client, app):
        """Test must_change_password flag enforcement"""
        with app.app_context():
            from src.extensions import db
            user_manager = UserManager()
            user = user_manager.create_user("testuser", "test@test.com", "Pass123")
            user.must_change_password = True
            db.session.commit()
            
            # Login to get token
            response = client.post("/api/v1/auth/login",
                                 json={"email": "test@test.com", "password": "Pass123"})
            token = response.json["access_token"]
            
            # Try to access protected endpoint
            response = client.get("/api/v1/user/1",
                                headers={"Authorization": f"Bearer {token}"})
            assert response.status_code == 403
            assert "PASSWORD_CHANGE_REQUIRED" in response.json.get("error_data", {}).get("code", "")