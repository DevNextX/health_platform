"""
Tests for Issue #50: User Experience Improvements - Timezone, Chart Y-axis and Abnormal Value Highlighting
Generated by Copilot
"""
import pytest
from datetime import datetime, UTC, timezone, timedelta
import json
from src.app import create_app
from src.extensions import db
from src.models import User, HealthRecord
from werkzeug.security import generate_password_hash


class TestIssue50Improvements:
    """Test user experience improvements from Issue #50"""
    
    @pytest.fixture
    def app(self):
        app = create_app()
        app.config.update({
            "TESTING": True,
            "SQLALCHEMY_DATABASE_URI": "sqlite:///:memory:",
            "JWT_SECRET_KEY": "test-secret-key"
        })
        
        with app.app_context():
            db.create_all()
            yield app
            
    @pytest.fixture
    def client(self, app):
        return app.test_client()
        
    @pytest.fixture
    def user_tokens(self, client):
        """Create user and return access tokens"""
        user_data = {
            "username": "tz_test_user",
            "email": "tz@test.com", 
            "password": "testpass123"
        }
        
        # Register user
        client.post("/api/v1/auth/register", json=user_data)
        
        # Login to get tokens
        login_resp = client.post("/api/v1/auth/login", json={
            "email": "tz@test.com",
            "password": "testpass123"
        })
        
        data = login_resp.get_json()
        return data["access_token"], data["refresh_token"]
    
    def test_timezone_consistency_create_and_retrieve(self, client, user_tokens):
        """Test AC1 & AC2: Timezone consistency when creating and retrieving records"""
        access_token, _ = user_tokens
        headers = {"Authorization": f"Bearer {access_token}"}
        
        # Create a record with a specific timestamp (simulating user input in local timezone)
        # This represents user in UTC+8 entering "2025-09-26 10:00"
        local_time = datetime(2025, 9, 26, 10, 0, 0)
        utc_time = local_time.replace(tzinfo=timezone.utc)  # Convert to UTC for API
        
        record_data = {
            "systolic": 120,
            "diastolic": 80,
            "heart_rate": 75,
            "timestamp": utc_time.isoformat().replace("+00:00", "Z"),
            "tags": ["测试"],
            "note": "Timezone test record"
        }
        
        # Create record
        create_resp = client.post("/api/v1/health", json=record_data, headers=headers)
        assert create_resp.status_code == 201
        
        created_record = create_resp.get_json()
        assert "timestamp" in created_record
        
        # Retrieve records
        list_resp = client.get("/api/v1/health", headers=headers)
        assert list_resp.status_code == 200
        
        records = list_resp.get_json()["records"]
        assert len(records) >= 1
        
        # Find our test record
        test_records = [r for r in records if r["note"] == "Timezone test record"]
        assert len(test_records) >= 1
        test_record = test_records[0]  # Use the first one found
        
        # Verify timestamp is returned in ISO format with Z suffix
        returned_timestamp = test_record["timestamp"]
        assert returned_timestamp.endswith("Z")
        
        # Parse the returned timestamp and verify it matches what we sent
        parsed_time = datetime.fromisoformat(returned_timestamp.replace("Z", "+00:00"))
        assert parsed_time == utc_time
        
        print(f"✓ Timezone consistency: sent {utc_time.isoformat()}, got {returned_timestamp}")
    
    def test_blood_pressure_abnormal_detection(self, client, user_tokens):
        """Test that abnormal BP values can be properly detected (for frontend highlighting)"""
        access_token, _ = user_tokens
        headers = {"Authorization": f"Bearer {access_token}"}
        
        # Create records with different BP levels
        test_cases = [
            {"systolic": 110, "diastolic": 70, "expected_normal": True, "note": "Normal BP"},
            {"systolic": 120, "diastolic": 79, "expected_normal": False, "note": "Systolic high"},  # systolic >= 120
            {"systolic": 119, "diastolic": 80, "expected_normal": False, "note": "Diastolic high"}, # diastolic >= 80
            {"systolic": 130, "diastolic": 85, "expected_normal": False, "note": "Both high"},     # Both high
            {"systolic": 119, "diastolic": 79, "expected_normal": True, "note": "Borderline normal"}
        ]
        
        created_records = []
        
        for i, case in enumerate(test_cases):
            record_data = {
                "systolic": case["systolic"],
                "diastolic": case["diastolic"],
                "heart_rate": 75,
                "timestamp": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
                "tags": [],
                "note": case["note"]
            }
            
            resp = client.post("/api/v1/health", json=record_data, headers=headers)
            assert resp.status_code == 201
            created_records.append((resp.get_json(), case))
        
        # Retrieve and verify records
        list_resp = client.get("/api/v1/health", headers=headers)
        assert list_resp.status_code == 200
        
        records = list_resp.get_json()["records"]
        
        # Verify BP classification logic (matches frontend implementation)
        for record in records:
            if record["note"] in [case["note"] for case in test_cases]:
                systolic = record["systolic"]
                diastolic = record["diastolic"]
                
                # Frontend logic: abnormal if systolic >= 120 OR diastolic >= 80
                is_abnormal_frontend = (systolic >= 120) or (diastolic >= 80)
                
                # Find the expected result
                expected_case = next(c for c in test_cases if c["note"] == record["note"])
                expected_normal = expected_case["expected_normal"]
                
                assert is_abnormal_frontend == (not expected_normal), \
                    f"BP {systolic}/{diastolic} classification mismatch for {record['note']}"
                
                print(f"✓ BP Classification: {systolic}/{diastolic} -> {'ABNORMAL' if is_abnormal_frontend else 'NORMAL'}")
    
    def test_chart_data_structure_compatibility(self, client, user_tokens):
        """Test that chart data is compatible with unified Y-axis implementation"""
        access_token, _ = user_tokens
        headers = {"Authorization": f"Bearer {access_token}"}
        
        # Create mixed data (BP + HR values in different ranges)
        test_records = [
            {"systolic": 120, "diastolic": 80, "heart_rate": 70},   # Mid-range
            {"systolic": 90, "diastolic": 60, "heart_rate": 60},    # Low-range
            {"systolic": 150, "diastolic": 100, "heart_rate": 90},  # High-range
            {"systolic": 110, "diastolic": 70, "heart_rate": None}, # No HR
        ]
        
        base_time = datetime.now(UTC) - timedelta(hours=4)
        
        for i, record in enumerate(test_records):
            record_data = {
                "systolic": record["systolic"],
                "diastolic": record["diastolic"], 
                "heart_rate": record["heart_rate"],
                "timestamp": (base_time + timedelta(hours=i)).isoformat().replace("+00:00", "Z"),
                "tags": [f"test{i}"],
                "note": f"Chart test {i}"
            }
            
            resp = client.post("/api/v1/health", json=record_data, headers=headers)
            assert resp.status_code == 201
        
        # Retrieve records
        list_resp = client.get("/api/v1/health", headers=headers)
        assert list_resp.status_code == 200
        
        records = list_resp.get_json()["records"]
        chart_records = [r for r in records if r["note"].startswith("Chart test")]
        
        # Since tests might create duplicate records, just verify we have the data we need
        assert len(chart_records) >= 4
        
        # Verify data ranges for unified Y-axis (should work with values from 60-150)
        all_values = []
        for record in chart_records:
            all_values.extend([
                record["systolic"], 
                record["diastolic"],
                record["heart_rate"] if record["heart_rate"] is not None else 0
            ])
        
        non_zero_values = [v for v in all_values if v > 0]
        min_val, max_val = min(non_zero_values), max(non_zero_values)
        
        print(f"✓ Chart data range: {min_val} - {max_val} (suitable for unified Y-axis 40-200)")
        
        # Verify all values fit within reasonable chart bounds
        assert all(40 <= v <= 200 for v in non_zero_values), \
            "Chart data should fit within unified Y-axis bounds (40-200)"
    
    def test_timestamp_parsing_edge_cases(self, client, user_tokens):
        """Test edge cases in timestamp handling"""
        access_token, _ = user_tokens
        headers = {"Authorization": f"Bearer {access_token}"}
        
        # Test various timestamp formats
        test_timestamps = [
            # ISO format with Z
            "2025-09-26T14:30:00Z",
            # ISO format with +00:00
            "2025-09-26T14:30:00+00:00",
            # Current time (no timestamp provided - should use server time)
            None
        ]
        
        for i, timestamp in enumerate(test_timestamps):
            record_data = {
                "systolic": 120 + i,
                "diastolic": 80 + i,
                "heart_rate": 75,
                "tags": [],
                "note": f"Timestamp test {i}"
            }
            
            if timestamp:
                record_data["timestamp"] = timestamp
            
            resp = client.post("/api/v1/health", json=record_data, headers=headers)
            assert resp.status_code == 201
            
            created = resp.get_json()
            returned_ts = created["timestamp"]
            
            # All timestamps should be normalized to Z format
            assert returned_ts.endswith("Z")
            
            # Should be parseable
            parsed = datetime.fromisoformat(returned_ts.replace("Z", "+00:00"))
            assert isinstance(parsed, datetime)
            
            print(f"✓ Timestamp format {i}: {timestamp} -> {returned_ts}")


# Run with: python -m pytest tests/test_issue_50.py -v