# Production Environment Deployment
# Generated by Zhuang
# Deploys to production with manual approval requirement

name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        type: string
      skip_approval:
        description: 'Skip manual approval (emergency only)'
        required: false
        type: boolean
        default: false

# GitHub Environment with protection rules
environment:
  name: production
  url: https://health-platform.example.com

permissions:
  contents: read
  packages: read

concurrency:
  group: deploy-prod
  cancel-in-progress: false  # Never cancel production deployments

jobs:
  # Pre-deployment validation
  pre-deploy:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.image.outputs.tag }}
      should-deploy: ${{ steps.validate.outputs.should-deploy }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set image tag
        id: image
        run: |
          if [ "${{ github.event.inputs.image_tag }}" != "" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=main-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Validate deployment readiness
        id: validate
        run: |
          echo "üîç Validating production deployment readiness..."
          
          # Check if required secrets are available
          if [ -z "${{ secrets.PROD_KUBE_CONFIG }}" ]; then
            echo "‚ùå Production Kubernetes config not found!"
            exit 1
          fi
          
          # Validate configuration files
          if [ ! -f "deploy/config/prod.env" ]; then
            echo "‚ùå Production config file not found!"
            exit 1
          fi
          
          # Check for any critical issues
          echo "‚úÖ Pre-deployment validation passed"
          echo "should-deploy=true" >> $GITHUB_OUTPUT

  # Manual approval gate (configured in GitHub Environment settings)
  approval:
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should-deploy == 'true' && github.event.inputs.skip_approval != 'true'
    environment: production  # This triggers the approval requirement
    steps:
      - name: Manual Approval Required
        run: |
          echo "‚è≥ Waiting for manual approval to deploy to production..."
          echo "Image Tag: ${{ needs.pre-deploy.outputs.image-tag }}"
          echo "Commit: ${{ github.sha }}"
          echo "Deployment will proceed after approval..."

  # Production deployment
  deploy:
    runs-on: ubuntu-latest
    needs: [pre-deploy, approval]
    if: always() && needs.pre-deploy.outputs.should-deploy == 'true' && (needs.approval.result == 'success' || github.event.inputs.skip_approval == 'true')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/k8s-set-context@v1
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.PROD_KUBE_CONFIG }}
          context: ${{ secrets.PROD_KUBE_CONTEXT }}

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y gettext-base

      # Create deployment backup
      - name: Backup current deployment
        env:
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        run: |
          echo "üíæ Creating deployment backup..."
          source deploy/config/prod.env
          
          if [ -n "$KUBE_CONTEXT" ]; then
            kubectl config use-context $KUBE_CONTEXT
          fi
          
          # Backup current deployment
          kubectl get deployment backend -n ${NAMESPACE} -o yaml > backup-backend-$(date +%Y%m%d-%H%M%S).yaml || echo "No backend deployment to backup"
          kubectl get deployment frontend -n ${NAMESPACE} -o yaml > backup-frontend-$(date +%Y%m%d-%H%M%S).yaml || echo "No frontend deployment to backup"

      # Blue-Green or Rolling deployment
      - name: Deploy to Production
        env:
          ENVIRONMENT: prod
          IMAGE_TAG: ${{ needs.pre-deploy.outputs.image-tag }}
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        run: |
          echo "üöÄ Starting Production deployment"
          echo "üì¶ Using image tag: ${IMAGE_TAG}"
          echo "‚ö†Ô∏è  Production deployment in progress - DO NOT INTERRUPT"
          
          # Load environment configuration
          source deploy/config/prod.env
          
          # Override image tag
          export IMAGE_TAG="${IMAGE_TAG}"
          
          # Set kubectl context
          if [ -n "$KUBE_CONTEXT" ]; then
            kubectl config use-context $KUBE_CONTEXT
          fi
          
          # Run deployment with extra validation
          chmod +x deploy/deploy-configurable.sh
          ./deploy/deploy-configurable.sh
          
          echo "üìã Deployment script completed"

      # Comprehensive health checks
      - name: Production Health Validation
        env:
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        timeout-minutes: 10
        run: |
          echo "üè• Running comprehensive health checks..."
          source deploy/config/prod.env
          
          # Wait for rollout to complete
          kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=300s
          kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=300s
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod -l app=backend -n ${NAMESPACE} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=frontend -n ${NAMESPACE} --timeout=300s
          
          # Get deployment status
          echo "üìä Deployment Status:"
          kubectl get pods,svc,deploy -n ${NAMESPACE}
          
          # Test service endpoints
          if [ "$SERVICE_TYPE" = "LoadBalancer" ]; then
            echo "üåê Testing service endpoints..."
            FRONTEND_IP=$(kubectl get svc frontend-svc -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            
            if [ -n "$FRONTEND_IP" ]; then
              echo "Production IP: ${FRONTEND_IP}"
              
              # Health check with retry
              for i in {1..10}; do
                if curl -f "http://${FRONTEND_IP}/api/health" --connect-timeout 10 --max-time 30; then
                  echo "‚úÖ Production health check passed!"
                  break
                elif [ $i -eq 10 ]; then
                  echo "‚ùå Production health check failed after 10 attempts"
                  exit 1
                else
                  echo "‚è≥ Health check attempt $i/10..."
                  sleep 30
                fi
              done
            fi
          fi

      # Post-deployment verification
      - name: Post-Deployment Verification
        env:
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        run: |
          echo "üîç Running post-deployment verification..."
          source deploy/config/prod.env
          
          # Check resource usage
          kubectl top pods -n ${NAMESPACE} || echo "Metrics not available"
          
          # Check for any error logs
          echo "üìã Recent backend logs:"
          kubectl logs -l app=backend -n ${NAMESPACE} --tail=50 --since=5m || echo "No backend logs"
          
          echo "üìã Recent frontend logs:"
          kubectl logs -l app=frontend -n ${NAMESPACE} --tail=50 --since=5m || echo "No frontend logs"
          
          # Final status check
          kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' --field-selector type!=Normal | tail -20 || echo "No warning events"

      - name: Deployment Success Notification
        if: success()
        run: |
          echo "üéâ Production deployment completed successfully!"
          echo "‚úÖ Environment: Production"
          echo "üì¶ Image Tag: ${{ needs.pre-deploy.outputs.image-tag }}"
          echo "üîó Commit: ${{ github.sha }}"
          echo "‚è∞ Deployed at: $(date -u)"
          # Add Slack/Teams/Email notifications here

      - name: Rollback on Failure
        if: failure()
        env:
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        run: |
          echo "‚ùå Production deployment failed - initiating rollback..."
          source deploy/config/prod.env
          
          if [ -n "$KUBE_CONTEXT" ]; then
            kubectl config use-context $KUBE_CONTEXT
          fi
          
          # Rollback deployments
          kubectl rollout undo deployment/backend -n ${NAMESPACE} || echo "Backend rollback failed"
          kubectl rollout undo deployment/frontend -n ${NAMESPACE} || echo "Frontend rollback failed"
          
          # Wait for rollback
          kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=300s
          kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=300s
          
          echo "üîÑ Rollback completed"
          # Add critical failure notifications here
