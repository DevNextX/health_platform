<!-- Generated by Zhuang -->

# Git policy and best practices for this Flask + React monorepo

This document defines our Git hygiene, lockfile strategy, and practical workflows for the `health_platform` repository.

Audience: contributors and maintainers of this project.

Version: 2025-08-29

---

## 1) Executive summary

- Only source code should be versioned. Dependencies, build outputs, local databases, and test reports must not be tracked.
- Prefer reproducible installs in CI and for releases. If we commit a lockfile, use deterministic install commands (e.g., `npm ci`).
- Use Conventional Commits, short-lived feature branches, and mandatory PR reviews with status checks.

---

## 2) Lockfile strategy (why, what to keep, and when)

Lockfiles (e.g., `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`) record exact dependency versions to ensure bit-for-bit reproducibility across machines and CI.

We distinguish two strategies:

1. Reproducible (recommended for deployed apps and CI-critical projects)
   - Commit one lockfile per Node project (e.g., `frontend/package-lock.json`, `tests/e2e/package-lock.json` if E2E is maintained as a separate Node project).
   - In CI and release pipelines, install with `npm ci` (or the tool matching the lockfile) to enforce exact versions.
   - Pros: deterministic builds, fewer “it works on my machine” issues.
   - Cons: periodic lockfile updates required.

2. Flexible (recommended for templates or libraries where reproducibility is less critical)
   - Do not commit lockfiles; rely on semver ranges and `npm install` to resolve latest compatible packages.
   - Pros: fewer merge conflicts in lockfiles, simpler maintenance.
   - Cons: higher risk of drift and breakage due to upstream changes; CI must pin versions another way if stability is required.

Current repository defaults were set to the Flexible strategy (ignoring lockfiles). If we need stronger reproducibility, switch to the Reproducible strategy for specific Node projects that ship to users or are executed in CI.

Python note:
- Python currently uses a `requirements.txt`. For stronger pinning, consider one of:
  - Maintain strict pins in `requirements.txt` (exact versions only).
  - Use `pip-tools` or `uv` to compile a fully resolved lock artifact (e.g., `requirements.lock.txt`) and commit it.
  - If adopting Poetry/Pipenv/PDN, commit the respective lockfiles, and adjust CI accordingly.

---

## 3) Applying the lockfile strategy in this repo

Recommended options:

- Option A (Conservative reproducibility; recommended for production):
  - Commit `frontend/package-lock.json`.
  - If `tests/e2e` is a separate Node project executed in CI, commit `tests/e2e/package-lock.json` too.
  - Update CI to use `npm ci` in those folders.
  - Remove ignore rules for these lockfiles from `.gitignore`.

- Option B (Current default; flexible):
  - Keep ignoring all lockfiles, install dynamically in dev and CI.
  - Accept periodic breakage risks from upstream dependency updates.

Checklist to switch to Option A (per Node project):
1) Remove the corresponding lockfile pattern from `.gitignore` (e.g., `frontend/package-lock.json`).
2) Ensure a fresh lockfile exists (e.g., run `npm install` in the project folder).
3) Commit the lockfile with a clear message (e.g., `chore(lockfile): commit frontend/package-lock.json for reproducible builds`).
4) Update CI to use `npm ci` in that folder.

---

## 4) Git ignore policy (what we exclude and why)

We ignore the following categories project-wide:

- Dependencies: `node_modules/` (and nested), Python virtual envs.
- Build and cache artifacts: frontend `build/`, ESLint/TypeScript caches, coverage artifacts.
- Local state and secrets: `.env*`, local SQLite/DB files, `instance/`.
- Test outputs: Playwright reports and result files.
- OS/editor noise: `.DS_Store`, `Thumbs.db`, etc.

Rationale: keep the repo small, clean, and free from machine-specific or sensitive data.

---

## 5) Branching, commits, and PR hygiene

- Branch strategy: GitHub Flow or trunk-based with short-lived feature branches: `feature/<scope>` or `fix/<scope>`.
- Commit messages: follow Conventional Commits (`feat:`, `fix:`, `chore:`, `docs:`, `refactor:`, `test:`, `build:`). Include scope when useful, keep body concise and actionable.
- Pull requests:
  - Small, focused PRs are easier to review.
  - Require CI checks (lint, unit tests, type checks) to pass before merge.
  - At least one reviewer approval; use CODEOWNERS for critical areas.
  - No direct commits to `main` for non-trivial changes.

---

## 6) Binaries, large files, and data

- Do not commit large binaries, archives, media, or generated assets.
- If truly needed, use Git LFS with explicit patterns and budget. Reassess periodically.
- Keep datasets out of the repo; prefer storage services or release artifacts.

---

## 7) Tooling consistency (line endings, formatting, hooks)

- Line endings: normalize with `.gitattributes` to reduce cross-OS diffs (e.g., LF for `.js/.ts/.py/.sh`, CRLF for `.bat`).
- EditorConfig: define indentation, charset, and EOL; commit `.editorconfig` to enforce consistent formatting.
- Pre-commit hooks:
  - JS/TS: ESLint + Prettier (optionally `lint-staged`).
  - Python: Ruff (lint) + Black (format) + isort (imports) where applicable.
  - Commit-msg hook for Conventional Commits (e.g., `commitlint`).

---

## 8) CI/CD integration

- Install steps:
  - With lockfile: use deterministic installers (`npm ci`) and pin Python deps.
  - Without lockfile: use `npm install` and accept variability; cache carefully.
- Quality gates: run lints and unit tests on every PR; smoke/e2e tests on main and before releases.
- Security: run dependency audits (`npm audit`, Python scanning) and secret scanning.

---

## 9) Maintenance and repository health

- Periodically run Git maintenance (`git gc`) to pack objects. If you see warnings about unreachable loose objects, run pruning as appropriate.
- Keep `.gitignore` and this document updated as the repo evolves (e.g., adding services or frameworks).

---

## 10) Quick reference (do/do-not)

Do:
- Commit source code, configs, and small text assets required to build.
- Commit lockfiles for deployable Node apps and CI-critical projects.
- Keep commits atomic and messages clear.

Do not:
- Commit `node_modules/`, local DB files, or test report outputs.
- Commit secrets or `.env` files; use environment variables or a secret manager.
- Force-push to `main` except for urgent, approved fixes.

---

## 11) Appendix: sample .gitattributes (optional)

Example to normalize line endings and mark common text types:

```
* text=auto eol=lf

*.sh  text eol=lf
*.py  text eol=lf
*.js  text eol=lf
*.ts  text eol=lf
*.jsx text eol=lf
*.tsx text eol=lf
*.json text eol=lf
*.css text eol=lf
*.md  text eol=lf
*.yml text eol=lf
*.yaml text eol=lf
*.bat text eol=crlf
```

---

Questions or proposals? Open an issue or PR updating this doc.
