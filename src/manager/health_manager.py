"""
Health manager layer. Generated by Zhuang
"""
import json
from datetime import datetime
from typing import List, Optional, Tuple
from sqlalchemy import and_, or_, select
from ..extensions import db
from ..models import HealthRecord, RecordSubject
from ..resilience.policy import db_breaker, with_retry


class HealthManager:
    @db_breaker
    @with_retry()
    def create(self, user_id: int, systolic: int, diastolic: int, heart_rate: Optional[int],
               timestamp: datetime, tags: List[str], note: Optional[str]) -> HealthRecord:
        rec = HealthRecord()
        rec.user_id = user_id
        rec.systolic = systolic
        rec.diastolic = diastolic
        rec.heart_rate = heart_rate
        rec.timestamp = timestamp
        # Generated by Zhuang: preserve non-ASCII characters for exact contains on Chinese tags
        rec.tags = json.dumps(tags, ensure_ascii=False)
        rec.note = note
        db.session.add(rec)
        db.session.commit()
        return rec

    def _base_query(self, user_id: int):
        return HealthRecord.query.filter_by(user_id=user_id)

    @db_breaker
    def get(self, user_id: int, rec_id: int) -> Optional[HealthRecord]:
        return HealthRecord.query.filter_by(id=rec_id, user_id=user_id).first()

    @db_breaker
    def count(self, user_id: int, q):
        return q.count()

    @db_breaker
    def list(self, user_id: int, page: int, size: int, tags: Optional[List[str]],
             date_from: Optional[datetime], date_to: Optional[datetime], subject_member_id: Optional[int] = None) -> Tuple[int, List[HealthRecord]]:
        q = self._base_query(user_id)
        if subject_member_id is not None:
            subq = select(RecordSubject.record_id).where(RecordSubject.member_id == subject_member_id)
            q = q.filter(HealthRecord.id.in_(subq))
        if tags:
            # Generated by Zhuang: Use OR semantics and exact tag match; support both raw and \u-escaped storage
            # per_tag_condition = OR(contains('"餐后"'), contains('"\u9910\u540e"'))
            conditions = []
            for t in tags:
                raw = f'"{t}"'
                escaped = json.dumps(t, ensure_ascii=True)  # includes surrounding quotes
                conditions.append(or_(HealthRecord.tags.contains(raw), HealthRecord.tags.contains(escaped)))
            if conditions:
                q = q.filter(or_(*conditions))
        if date_from:
            q = q.filter(HealthRecord.timestamp >= date_from)
        if date_to:
            q = q.filter(HealthRecord.timestamp <= date_to)
        total = q.count()
        items = q.order_by(HealthRecord.timestamp.desc()).offset((page - 1) * size).limit(size).all()
        return total, items

    @db_breaker
    def list_all(self, user_id: int, tags: Optional[List[str]],
                 date_from: Optional[datetime], date_to: Optional[datetime], subject_member_id: Optional[int] = None) -> List[HealthRecord]:
        """Return all records matching the filters without pagination. Generated by Zhuang"""
        q = self._base_query(user_id)
        if subject_member_id is not None:
            subq = select(RecordSubject.record_id).where(RecordSubject.member_id == subject_member_id)
            q = q.filter(HealthRecord.id.in_(subq))
        if tags:
            # Generated by Zhuang: OR semantics; support raw and escaped forms
            conditions = []
            for t in tags:
                raw = f'"{t}"'
                escaped = json.dumps(t, ensure_ascii=True)
                conditions.append(or_(HealthRecord.tags.contains(raw), HealthRecord.tags.contains(escaped)))
            if conditions:
                q = q.filter(or_(*conditions))
        if date_from:
            q = q.filter(HealthRecord.timestamp >= date_from)
        if date_to:
            q = q.filter(HealthRecord.timestamp <= date_to)
        return q.order_by(HealthRecord.timestamp.asc()).all()

    @db_breaker
    @with_retry()
    def update(self, rec: HealthRecord, **fields) -> HealthRecord:
        for k, v in fields.items():
            if hasattr(rec, k):
                setattr(rec, k, v)
        db.session.commit()
        return rec

    @db_breaker
    @with_retry()
    def delete(self, rec: HealthRecord):
        db.session.delete(rec)
        db.session.commit()
