"""
Health manager layer. Generated by Zhuang
"""
import json
from datetime import datetime
from typing import List, Optional, Tuple
from sqlalchemy import and_
from ..extensions import db
from ..models import HealthRecord
from ..resilience.policy import db_breaker, with_retry


class HealthManager:
    @db_breaker
    @with_retry()
    def create(self, user_id: int, systolic: int, diastolic: int, heart_rate: Optional[int],
               timestamp: datetime, tags: List[str], note: Optional[str]) -> HealthRecord:
        rec = HealthRecord()
        rec.user_id = user_id
        rec.systolic = systolic
        rec.diastolic = diastolic
        rec.heart_rate = heart_rate
        rec.timestamp = timestamp
        rec.tags = json.dumps(tags)
        rec.note = note
        db.session.add(rec)
        db.session.commit()
        return rec

    def _base_query(self, user_id: int):
        return HealthRecord.query.filter_by(user_id=user_id)

    @db_breaker
    def get(self, user_id: int, rec_id: int) -> Optional[HealthRecord]:
        return HealthRecord.query.filter_by(id=rec_id, user_id=user_id).first()

    @db_breaker
    def count(self, user_id: int, q):
        return q.count()

    @db_breaker
    def list(self, user_id: int, page: int, size: int, tags: Optional[List[str]],
             date_from: Optional[datetime], date_to: Optional[datetime]) -> Tuple[int, List[HealthRecord]]:
        q = self._base_query(user_id)
        
        # Apply date filters first at the database level
        if date_from:
            q = q.filter(HealthRecord.timestamp >= date_from)
        if date_to:
            q = q.filter(HealthRecord.timestamp <= date_to)
            
        # For tag filtering, we need to handle JSON properly
        if tags:
            # Get all records matching date criteria first
            all_records = q.order_by(HealthRecord.timestamp.desc()).all()
            
            # Filter by tags in Python to handle JSON properly
            filtered_records = []
            for record in all_records:
                if record.tags:
                    try:
                        record_tags = json.loads(record.tags)
                        # Check if any of the search tags are in the record's tags
                        if any(tag in record_tags for tag in tags):
                            filtered_records.append(record)
                    except (json.JSONDecodeError, TypeError):
                        # Skip records with invalid JSON
                        continue
            
            total = len(filtered_records)
            # Apply pagination to the filtered results
            start_idx = (page - 1) * size
            end_idx = start_idx + size
            items = filtered_records[start_idx:end_idx]
        else:
            # No tag filtering, use database pagination
            total = q.count()
            items = q.order_by(HealthRecord.timestamp.desc()).offset((page - 1) * size).limit(size).all()
            
        return total, items

    @db_breaker
    @with_retry()
    def update(self, rec: HealthRecord, **fields) -> HealthRecord:
        for k, v in fields.items():
            if hasattr(rec, k):
                setattr(rec, k, v)
        db.session.commit()
        return rec

    @db_breaker
    @with_retry()
    def delete(self, rec: HealthRecord):
        db.session.delete(rec)
        db.session.commit()
