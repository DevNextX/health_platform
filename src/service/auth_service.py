"""
Auth service endpoints: register, login, refresh, logout, logout-all. Generated by Zhuang
"""
import secrets
from datetime import timedelta, datetime
from flask import Blueprint, request, jsonify
from flask_jwt_extended import (
    jwt_required,
    get_jwt,
    get_jwt_identity,
)
from ..extensions import limiter, db
from flask import current_app
from ..manager.user_manager import UserManager
from ..manager.member_manager import MemberManager
from ..manager.wechat_manager import WeChatManager
from ..manager.state_storage import create_state_storage
from ..models import User
from ..security import verify_password, hash_password, make_tokens
from ..utils import error

auth_bp = Blueprint("auth", __name__)
user_manager = UserManager()
member_manager = MemberManager()
wechat_manager = WeChatManager()

# State storage for WeChat authentication (Redis-backed with in-memory fallback)
_state_storage = None


def _get_state_storage():
    """Lazy initialization of state storage"""
    global _state_storage
    if _state_storage is None:
        _state_storage = create_state_storage()
    return _state_storage


@auth_bp.route("/register", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def register():
    data = request.get_json(force=True) or {}
    required = ["username", "email", "password"]
    if any(not data.get(k) for k in required):
        return jsonify(error("400", "Missing required fields", {"required": required})), 400
    try:
        user = user_manager.create_user(
            username=data["username"],
            email=data["email"],
            password=data["password"],
            age=data.get("age"),
            gender=data.get("gender"),
            weight=data.get("weight"),
        )
        # Generated by Zhuang: if height provided at registration, write it to Self member
        if "height" in data and data.get("height") is not None:
            try:
                self_member = member_manager.get_or_create_self_member(user.id)
                member_manager.update_member(self_member, height=data.get("height"))
            except Exception:
                pass
    except ValueError as e:
        if str(e) == "EMAIL_EXISTS":
            return jsonify(error("409", "Email already exists")), 409
        raise
    return jsonify({
        "id": user.id,
        "username": user.username,
        "email": user.email,
        "created_at": user.created_at.isoformat() + "Z",
    }), 201


@auth_bp.route("/login", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def login():
    data = request.get_json(force=True) or {}
    email = data.get("email")
    password = data.get("password")
    if not email or not password:
        return jsonify(error("400", "Email and password required")), 400
    user = user_manager.get_user_by_email(email)
    # Check if user exists and has a password set (WeChat-only users have password_hash=None)
    if not user or not user.password_hash or not verify_password(password, user.password_hash):
        return jsonify(error("401", "Invalid credentials")), 401

    tokens = make_tokens(identity=user.id, token_version=user.token_version)
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
    }), 200


@auth_bp.route("/refresh", methods=["POST"])
@jwt_required(refresh=True)
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def refresh():
    identity = get_jwt_identity()
    claims = get_jwt()
    user = user_manager.get_user(identity)
    if not user or claims.get("token_version") != user.token_version:
        return jsonify(error("401", "Token revoked")), 401
    tokens = make_tokens(identity=user.id, token_version=user.token_version)
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
    }), 200


@auth_bp.route("/logout", methods=["POST"])
@jwt_required(refresh=True)
def logout():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    # Bump token version to invalidate current refresh token
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out"}), 200


@auth_bp.route("/logout-all", methods=["POST"])
@jwt_required()
def logout_all():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out all sessions"}), 200


@auth_bp.route("/wechat/login", methods=["GET"])
@auth_bp.route("/wechat/login", methods=["GET"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def wechat_login():
    """
    Generate WeChat QR code URL for login
    Returns the URL that frontend should use to display QR code
    """
    try:
        storage = _get_state_storage()
        storage.cleanup_expired()
        
        # Generate random state to prevent CSRF
        state = secrets.token_urlsafe(32)
        storage.set(state, {
            "timestamp": datetime.utcnow().isoformat(),
            "used": False
        })
        
        qrcode_url = wechat_manager.get_qrcode_url(state)
        
        return jsonify({
            "qrcode_url": qrcode_url,
            "state": state
        }), 200
    except ValueError as e:
        current_app.logger.error(f"WeChat configuration error: {e}")
        return jsonify(error("500", "WeChat configuration error")), 500
    except Exception as e:
        current_app.logger.error(f"WeChat login error: {e}")
        return jsonify(error("500", "Failed to generate QR code")), 500


@auth_bp.route("/wechat/callback", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def wechat_callback():
    """
    Handle WeChat authorization callback
    Exchange code for access token and get user's openid
    """
    data = request.get_json(force=True) or {}
    code = data.get("code")
    state = data.get("state")
    
    if not code or not state:
        return jsonify(error("400", "Missing code or state")), 400
    
    storage = _get_state_storage()
    
    # Verify state to prevent CSRF
    state_data = storage.get(state)
    if not state_data or state_data.get("used"):
        return jsonify(error("400", "Invalid or expired state")), 400
    
    # Mark state as used
    state_data["used"] = True
    storage.set(state, state_data)
    
    try:
        # Exchange code for access token
        token_data = wechat_manager.get_access_token(code)
        if not token_data:
            return jsonify(error("500", "Failed to get access token from WeChat")), 500
        
        openid = token_data.get("openid")
        if not openid:
            return jsonify(error("500", "No openid returned from WeChat")), 500
        
        # Store openid in state for bind endpoint
        state_data["openid"] = openid
        storage.set(state, state_data)
        
        # Check if user already exists
        existing_user = user_manager.get_user_by_wechat_openid(openid)
        
        if existing_user:
            # User exists, log them in directly
            tokens = make_tokens(identity=existing_user.id, token_version=existing_user.token_version)
            return jsonify({
                "status": "existing_user",
                "access_token": tokens["access_token"],
                "expires_in": 60 * 30,
                "refresh_token": tokens["refresh_token"],
                "refresh_expires_in": 60 * 60 * 24 * 7,
                "token_type": "Bearer",
            }), 200
        else:
            # New user, need to bind email
            return jsonify({
                "status": "new_user",
                "state": state,
                "message": "Please bind your email"
            }), 200
            
    except Exception as e:
        current_app.logger.error(f"WeChat callback error: {e}")
        return jsonify(error("500", "WeChat authentication failed")), 500


@auth_bp.route("/wechat/bind", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def wechat_bind():
    """
    Bind email (and optional password) to WeChat account
    Creates a new user account linked to WeChat OpenID
    """
    data = request.get_json(force=True) or {}
    state = data.get("state")
    email = data.get("email")
    username = data.get("username")
    password = data.get("password")  # Optional
    
    if not state or not email or not username:
        return jsonify(error("400", "Missing required fields: state, email, username")), 400
    
    storage = _get_state_storage()
    
    # Verify state
    state_data = storage.get(state)
    if not state_data:
        return jsonify(error("400", "Invalid or expired state")), 400
    
    openid = state_data.get("openid")
    
    if not openid:
        return jsonify(error("400", "No WeChat OpenID found for this state")), 400
    
    try:
        # Create new user with WeChat OpenID
        user = user_manager.create_wechat_user(
            username=username,
            email=email,
            wechat_openid=openid,
            password=password,  # Can be None
            age=data.get("age"),
            gender=data.get("gender"),
            weight=data.get("weight")
        )
        
        # Create Self member if height provided
        if "height" in data and data.get("height") is not None:
            try:
                self_member = member_manager.get_or_create_self_member(user.id)
                member_manager.update_member(self_member, height=data.get("height"))
            except Exception as e:
                current_app.logger.error(f"Failed to create/update Self member height for user {user.id}: {e}")
        
        # Clean up state
        storage.delete(state)
        
        # Generate tokens and log user in
        tokens = make_tokens(identity=user.id, token_version=user.token_version)
        
        return jsonify({
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "access_token": tokens["access_token"],
            "expires_in": 60 * 30,
            "refresh_token": tokens["refresh_token"],
            "refresh_expires_in": 60 * 60 * 24 * 7,
            "token_type": "Bearer",
            "created_at": user.created_at.isoformat() + "Z",
        }), 201
        
    except ValueError as e:
        error_msg = str(e)
        if error_msg == "EMAIL_EXISTS":
            return jsonify(error("409", "Email already exists")), 409
        elif error_msg == "WECHAT_OPENID_EXISTS":
            return jsonify(error("409", "WeChat account already bound")), 409
        raise
    except Exception as e:
        current_app.logger.error(f"WeChat bind error: {e}")
        return jsonify(error("500", "Failed to bind account")), 500
