"""
Auth service endpoints: register, login, refresh, logout, logout-all. Generated by Zhuang
"""
from datetime import timedelta, datetime
from ..timeutil import UTC
from flask import Blueprint, request, jsonify
from flask_jwt_extended import (
    jwt_required,
    get_jwt,
    get_jwt_identity,
)
from ..extensions import limiter
from flask import current_app
from ..manager.user_manager import UserManager
from ..manager.member_manager import MemberManager
from ..models import User
from ..security import verify_password, hash_password, make_tokens, validate_password_strength
from ..utils import error

auth_bp = Blueprint("auth", __name__)
user_manager = UserManager()
member_manager = MemberManager()


@auth_bp.route("/register", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def register():
    data = request.get_json(force=True) or {}
    required = ["username", "email", "password"]
    if any(not data.get(k) for k in required):
        return jsonify(error("400", "Missing required fields", {"required": required})), 400
    # Enforce password strength
    if not validate_password_strength(data.get("password")):
        return jsonify(error("400", "Password must be at least 8 characters and include letters and numbers")), 400
    try:
        user = user_manager.create_user(
            username=data["username"],
            email=data["email"],
            password=data["password"],
            age=data.get("age"),
            gender=data.get("gender"),
            weight=data.get("weight"),
        )
        # Generated by Zhuang: if height provided at registration, write it to Self member
        if "height" in data and data.get("height") is not None:
            try:
                self_member = member_manager.get_or_create_self_member(user.id)
                member_manager.update_member(self_member, height=data.get("height"))
            except Exception:
                pass
    except ValueError as e:
        if str(e) == "EMAIL_EXISTS":
            return jsonify(error("409", "Email already exists")), 409
        raise
    return jsonify({
        "id": user.id,
        "username": user.username,
        "email": user.email,
        "created_at": (user.created_at if user.created_at.tzinfo else user.created_at.replace(tzinfo=UTC)).isoformat().replace("+00:00", "Z"),
    }), 201


@auth_bp.route("/login", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def login():
    data = request.get_json(force=True) or {}
    email = data.get("email")
    username = data.get("username")
    password = data.get("password")
    if not (email or username) or not password:
        # Keep backward-compatible message for existing tests
        if email and not password:
            return jsonify(error("400", "Email and password required")), 400
        return jsonify(error("400", "Email and password required")), 400
    user = None
    if email:
        user = user_manager.get_user_by_email(email)
    if not user and username:
        user = user_manager.get_user_by_username_ci(username)
    if not user or not verify_password(password, user.password_hash):
        return jsonify(error("401", "Invalid credentials")), 401

    # Update last login timestamp
    try:
        user_manager.set_last_login(user)
    except Exception:
        pass

    tokens = make_tokens(identity=user.id, token_version=user.token_version, additional_claims={
        "role": user.role,
        "must_change_password": user.must_change_password,
    })
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
        "must_change_password": user.must_change_password,
    }), 200


@auth_bp.route("/refresh", methods=["POST"])
@jwt_required(refresh=True)
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def refresh():
    identity = get_jwt_identity()
    claims = get_jwt()
    user = user_manager.get_user(identity)
    if not user or claims.get("token_version") != user.token_version:
        return jsonify(error("401", "Token revoked")), 401
    tokens = make_tokens(identity=user.id, token_version=user.token_version, additional_claims={
        "role": user.role,
        "must_change_password": user.must_change_password,
    })
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
    }), 200


@auth_bp.route("/logout", methods=["POST"])
@jwt_required(refresh=True)
def logout():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    # Bump token version to invalidate current refresh token
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out"}), 200


@auth_bp.route("/logout-all", methods=["POST"])
@jwt_required()
def logout_all():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out all sessions"}), 200


@auth_bp.route("/change-password", methods=["POST"])
@jwt_required()
def change_password():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    data = request.get_json(force=True) or {}
    current_password = data.get("current_password")
    new_password = data.get("new_password")
    if not current_password or not new_password:
        return jsonify(error("400", "Current and new passwords required")), 400
    if not verify_password(current_password, user.password_hash):
        return jsonify(error("401", "Current password incorrect")), 401
    if not validate_password_strength(new_password):
        return jsonify(error("400", "Password must be at least 8 characters and include letters and numbers")), 400
    user_manager.set_password(user, new_password, force_change_next_login=False)
    # Issue new tokens reflecting updated claims and token_version
    tokens = make_tokens(identity=user.id, token_version=user.token_version, additional_claims={
        "role": user.role,
        "must_change_password": user.must_change_password,
    })
    return jsonify({
        "message": "Password changed",
        "access_token": tokens["access_token"],
        "refresh_token": tokens["refresh_token"],
        "token_type": "Bearer",
        "expires_in": 60 * 30,
        "refresh_expires_in": 60 * 60 * 24 * 7,
    }), 200
