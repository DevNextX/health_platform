"""
Auth service endpoints: register, login, refresh, logout, logout-all. Generated by Zhuang
"""
from datetime import timedelta
from flask import Blueprint, request, jsonify
from flask_jwt_extended import (
    jwt_required,
    get_jwt,
    get_jwt_identity,
)
from ..extensions import limiter
from flask import current_app
from ..manager.user_manager import UserManager
from ..manager.member_manager import MemberManager
from ..models import User
from ..security import verify_password, hash_password, make_tokens
from ..utils import error

auth_bp = Blueprint("auth", __name__)
user_manager = UserManager()
member_manager = MemberManager()


@auth_bp.route("/register", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def register():
    data = request.get_json(force=True) or {}
    required = ["username", "email", "password"]
    if any(not data.get(k) for k in required):
        return jsonify(error("400", "Missing required fields", {"required": required})), 400
    try:
        user = user_manager.create_user(
            username=data["username"],
            email=data["email"],
            password=data["password"],
            age=data.get("age"),
            gender=data.get("gender"),
            weight=data.get("weight"),
        )
        # Generated by Zhuang: if height provided at registration, write it to Self member
        if "height" in data and data.get("height") is not None:
            try:
                self_member = member_manager.get_or_create_self_member(user.id)
                member_manager.update_member(self_member, height=data.get("height"))
            except Exception as e:
                # Height update failure is non-critical; ignore error so user registration proceeds.
                import logging
                logging.warning(f"Failed to update member height during registration: {e}")
                pass
    except ValueError as e:
        if str(e) == "EMAIL_EXISTS":
            return jsonify(error("409", "Email already exists")), 409
        raise
    return jsonify({
        "id": user.id,
        "username": user.username,
        "email": user.email,
        "created_at": user.created_at.isoformat() + "Z",
    }), 201


@auth_bp.route("/login", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def login():
    data = request.get_json(force=True) or {}
    email = data.get("email")
    password = data.get("password")
    if not email or not password:
        return jsonify(error("400", "Email and password required")), 400
    user = user_manager.get_user_by_email(email)
    if not user or not verify_password(password, user.password_hash):
        return jsonify(error("401", "Invalid credentials")), 401

    tokens = make_tokens(identity=user.id, token_version=user.token_version)
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
    }), 200


@auth_bp.route("/refresh", methods=["POST"])
@jwt_required(refresh=True)
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def refresh():
    identity = get_jwt_identity()
    claims = get_jwt()
    user = user_manager.get_user(identity)
    if not user or claims.get("token_version") != user.token_version:
        return jsonify(error("401", "Token revoked")), 401
    tokens = make_tokens(identity=user.id, token_version=user.token_version)
    return jsonify({
        "access_token": tokens["access_token"],
        "expires_in": 60 * 30,
        "refresh_token": tokens["refresh_token"],
        "refresh_expires_in": 60 * 60 * 24 * 7,
        "token_type": "Bearer",
    }), 200


@auth_bp.route("/logout", methods=["POST"])
@jwt_required(refresh=True)
def logout():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    # Bump token version to invalidate current refresh token
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out"}), 200


@auth_bp.route("/logout-all", methods=["POST"])
@jwt_required()
def logout_all():
    identity = get_jwt_identity()
    user = user_manager.get_user(identity)
    if not user:
        return jsonify(error("401", "Invalid token")), 401
    user_manager.bump_token_version(user)
    return jsonify({"message": "Logged out all sessions"}), 200
