"""
WeChat mini-app service endpoints. Generated by Copilot
"""
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..extensions import limiter
from ..manager.wechat_manager import WeChatManager
from ..manager.user_manager import UserManager
from ..manager.member_manager import MemberManager
from ..security import make_tokens
from ..utils import error

wechat_bp = Blueprint("wechat", __name__)
wechat_manager = WeChatManager()
user_manager = UserManager()
member_manager = MemberManager()


@wechat_bp.route("/auth/login", methods=["POST"])
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def wechat_login():
    """
    WeChat mini-app login endpoint.
    
    Request body:
        {
            "code": "js_code from wx.login()",
            "userInfo": {  # optional
                "nickName": "user nickname",
                "avatarUrl": "user avatar"
            }
        }
    
    Response:
        {
            "access_token": "JWT access token",
            "refresh_token": "JWT refresh token",
            "expires_in": 1800,
            "refresh_expires_in": 604800,
            "token_type": "Bearer",
            "user": {
                "id": 1,
                "username": "username",
                "email": "email@example.com",
                "is_wechat_temp": true  # if using temporary email
            }
        }
    """
    data = request.get_json(force=True) or {}
    js_code = data.get("code")
    user_info = data.get("userInfo")
    
    if not js_code:
        return jsonify(error("400", "Missing code parameter")), 400
    
    # Exchange code for openid and session_key
    session_data = wechat_manager.code2session(js_code)
    
    if not session_data:
        return jsonify(error("401", "Invalid WeChat code or API error")), 401
    
    openid = session_data.get("openid")
    session_key = session_data.get("session_key")
    unionid = session_data.get("unionid")
    
    if not openid or not session_key:
        return jsonify(error("401", "Failed to obtain WeChat session")), 401
    
    # Get or create user
    user = wechat_manager.get_or_create_user_by_openid(
        openid=openid,
        session_key=session_key,
        unionid=unionid,
        user_info=user_info
    )
    
    # Create Self member if not exists
    try:
        member_manager.get_or_create_self_member(user.id)
    except (ValueError, AttributeError) as e:
        # Log error but continue - member creation failure shouldn't block login
        pass
    
    # Generate JWT tokens
    tokens = make_tokens(identity=user.id, token_version=user.token_version)
    
    # Check if user is using temporary email
    is_temp_email = user.email.startswith("wechat_") and user.email.endswith("@temp.local")
    
    return jsonify({
        "access_token": tokens["access_token"],
        "refresh_token": tokens["refresh_token"],
        "expires_in": 60 * 30,  # 30 minutes
        "refresh_expires_in": 60 * 60 * 24 * 7,  # 7 days
        "token_type": "Bearer",
        "user": {
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "is_wechat_temp": is_temp_email
        }
    }), 200


@wechat_bp.route("/auth/bind", methods=["POST"])
@jwt_required()
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def bind_wechat():
    """
    Bind WeChat account to existing logged-in user.
    
    Request body:
        {
            "code": "js_code from wx.login()"
        }
    
    Response:
        {
            "message": "WeChat account bound successfully"
        }
    """
    user_id = get_jwt_identity()
    data = request.get_json(force=True) or {}
    js_code = data.get("code")
    
    if not js_code:
        return jsonify(error("400", "Missing code parameter")), 400
    
    # Exchange code for openid and session_key
    session_data = wechat_manager.code2session(js_code)
    
    if not session_data:
        return jsonify(error("401", "Invalid WeChat code or API error")), 401
    
    openid = session_data.get("openid")
    session_key = session_data.get("session_key")
    unionid = session_data.get("unionid")
    
    if not openid or not session_key:
        return jsonify(error("401", "Failed to obtain WeChat session")), 401
    
    # Bind WeChat to user
    success = wechat_manager.bind_wechat_to_user(
        user_id=user_id,
        openid=openid,
        session_key=session_key,
        unionid=unionid
    )
    
    if not success:
        return jsonify(error("409", "WeChat account already bound to another user")), 409
    
    return jsonify({"message": "WeChat account bound successfully"}), 200


@wechat_bp.route("/auth/unbind", methods=["POST"])
@jwt_required()
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def unbind_wechat():
    """
    Unbind WeChat account from current user.
    
    Response:
        {
            "message": "WeChat account unbound successfully"
        }
    """
    user_id = get_jwt_identity()
    
    success = wechat_manager.unbind_wechat_from_user(user_id)
    
    if not success:
        return jsonify(error("404", "User not found")), 404
    
    return jsonify({"message": "WeChat account unbound successfully"}), 200


@wechat_bp.route("/auth/update-email", methods=["POST"])
@jwt_required()
@limiter.limit(lambda: current_app.config.get("RATELIMIT_AUTH", "5 per minute"))
def update_wechat_user_email():
    """
    Update email for WeChat-only user (with temporary email).
    
    Request body:
        {
            "email": "new_email@example.com",
            "password": "new_password"  # optional, set password for email login
        }
    
    Response:
        {
            "message": "Email updated successfully",
            "user": {
                "id": 1,
                "username": "username",
                "email": "new_email@example.com"
            }
        }
    """
    user_id = get_jwt_identity()
    data = request.get_json(force=True) or {}
    
    new_email = data.get("email")
    password = data.get("password")
    
    if not new_email:
        return jsonify(error("400", "Email is required")), 400
    
    user = user_manager.get_user(user_id)
    if not user:
        return jsonify(error("404", "User not found")), 404
    
    # Check if email is already taken
    existing = user_manager.get_user_by_email(new_email)
    if existing and existing.id != user_id:
        return jsonify(error("409", "Email already exists")), 409
    
    # Update user
    try:
        update_data = {"email": new_email}
        if password:
            update_data["password"] = password
        
        user_manager.update_user(user, **update_data)
    except ValueError as e:
        if str(e) == "EMAIL_EXISTS":
            return jsonify(error("409", "Email already exists")), 409
        raise
    
    return jsonify({
        "message": "Email updated successfully",
        "user": {
            "id": user.id,
            "username": user.username,
            "email": user.email
        }
    }), 200
