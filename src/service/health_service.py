"""
Health service endpoints. Generated by Zhuang
"""
import json
from datetime import datetime, UTC
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy import and_, select
from ..manager.health_manager import HealthManager
from ..manager.member_manager import MemberManager
from ..models import RecordSubject
from ..utils import get_pagination_params, make_pagination, error

health_bp = Blueprint("health", __name__)
manager = HealthManager()
member_mgr = MemberManager()


@health_bp.route("", methods=["POST"])
@jwt_required()
def create_record():
    user_id = get_jwt_identity()
    data = request.get_json(force=True) or {}
    try:
        systolic = int(data.get("systolic"))
        diastolic = int(data.get("diastolic"))
    except (TypeError, ValueError):
        return jsonify(error("400", "Invalid blood pressure")), 400
    if not (50 <= systolic <= 250) or not (50 <= diastolic <= 250):
        return jsonify(error("422", "Blood pressure out of range (50-250)")), 422
    heart_rate = data.get("heart_rate")
    if heart_rate is not None:
        try:
            heart_rate = int(heart_rate)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid heart_rate")), 400
    ts_raw = data.get("timestamp")
    # Use timezone-aware UTC datetime to avoid deprecation warnings
    ts = datetime.now(UTC) if not ts_raw else datetime.fromisoformat(ts_raw.replace("Z", "+00:00"))
    tags = data.get("tags") or []
    if not isinstance(tags, list):
        return jsonify(error("400", "tags must be a list")), 400
    note = data.get("note")

    # Determine subject member (default to self member if not provided)
    subject_member_id = data.get("subject_member_id")
    if subject_member_id is not None:
        try:
            subject_member_id = int(subject_member_id)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid subject_member_id")), 400
        # Validate member belongs to current user's household
        m = member_mgr.get_member(user_id, subject_member_id)
        if not m or m.status != "active":
            return jsonify(error("404", "Member not found")), 404
    else:
        m = member_mgr.get_or_create_self_member(user_id)
        subject_member_id = m.id

    rec = manager.create(user_id=user_id, systolic=systolic, diastolic=diastolic, heart_rate=heart_rate,
                         timestamp=ts, tags=tags, note=note)
    # Link record to subject
    rs = RecordSubject()
    hh = member_mgr.ensure_default_household(user_id)
    rs.record_id = rec.id
    rs.household_id = hh.id
    rs.member_id = subject_member_id
    rs.created_by_user_id = user_id
    from ..extensions import db
    db.session.add(rs)
    db.session.commit()
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
    # Normalize UTC offset to trailing 'Z' for clients
    "timestamp": rec.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": tags,
        "note": rec.note,
    "created_at": rec.created_at.isoformat().replace("+00:00", "Z"),
    "subject_member_id": subject_member_id,
    }), 201


@health_bp.route("", methods=["GET"])
@jwt_required()
def list_records():
    user_id = get_jwt_identity()
    page, size = get_pagination_params()
    # Build filters
    tags_q = request.args.get("tags")
    tag_list = None
    if tags_q:
        tag_list = [x.strip() for x in tags_q.split(",") if x.strip()]

    date_from = request.args.get("date_from")
    date_to = request.args.get("date_to")
    df = None
    dt = None
    if date_from:
        try:
            df = datetime.fromisoformat(date_from.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_from")), 400
    if date_to:
        try:
            dt = datetime.fromisoformat(date_to.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_to")), 400

    # Filter by member if provided
    subject_member_id = request.args.get("subject_member_id")
    # Generated by Zhuang: always resolve self_member for potential lazy backfill
    self_member = member_mgr.get_or_create_self_member(user_id)
    if subject_member_id is not None:
        try:
            subject_member_id = int(subject_member_id)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid subject_member_id")), 400
        # Validate membership
        m = member_mgr.get_member(user_id, subject_member_id)
        if not m:
            return jsonify(error("404", "Member not found")), 404
        # Generated by Zhuang: if explicitly filtering by Self, still perform lazy backfill
        if m.id == self_member.id:
            from ..models import HealthRecord
            from ..extensions import db
            subq = select(RecordSubject.record_id)
            unmapped = db.session.query(HealthRecord.id).\
                filter(HealthRecord.user_id == user_id).\
                filter(~HealthRecord.id.in_(subq)).all()
            if unmapped:
                hh = member_mgr.ensure_default_household(user_id)
                for (rid,) in unmapped:
                    rs = RecordSubject()
                    rs.record_id = rid
                    rs.household_id = hh.id
                    rs.member_id = self_member.id
                    rs.created_by_user_id = user_id
                    db.session.add(rs)
                db.session.commit()
    else:
        # Backfill legacy records to Self for this user lazily to ensure Self can see data
        # If no subject_member_id specified, do not filter, but ensure mappings exist for future Self queries
        from ..models import HealthRecord
        from ..extensions import db
        # Find records without mapping
        subq = select(RecordSubject.record_id)
        unmapped = db.session.query(HealthRecord.id).filter(HealthRecord.user_id == user_id).filter(
            ~HealthRecord.id.in_(subq)
        ).all()
        if unmapped:
            hh = member_mgr.ensure_default_household(user_id)
            for (rid,) in unmapped:
                rs = RecordSubject()
                rs.record_id = rid
                rs.household_id = hh.id
                rs.member_id = self_member.id
                rs.created_by_user_id = user_id
                db.session.add(rs)
            db.session.commit()

    total, items = manager.list(user_id=user_id, page=page, size=size, tags=tag_list, date_from=df, date_to=dt,
                                subject_member_id=subject_member_id)
    # Optionally include subject_member_id by querying mapping
    # To keep it lightweight, include only when a single member filter is active
    include_subject = subject_member_id is not None
    data = [{
        "id": r.id,
        "systolic": r.systolic,
        "diastolic": r.diastolic,
        "heart_rate": r.heart_rate,
    "timestamp": r.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": json.loads(r.tags) if r.tags else [],
        "note": r.note,
        **({"subject_member_id": subject_member_id} if include_subject else {}),
    } for r in items]
    return jsonify({"records": data, "pagination": make_pagination(page, size, total)}), 200


@health_bp.route("/<int:rec_id>", methods=["GET"])
@jwt_required()
def get_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
    "timestamp": rec.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": json.loads(rec.tags) if rec.tags else [],
        "note": rec.note,
    "created_at": rec.created_at.isoformat().replace("+00:00", "Z"),
    }), 200


@health_bp.route("/<int:rec_id>", methods=["PUT"])
@jwt_required()
def update_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    data = request.get_json(force=True) or {}
    if "systolic" in data:
        try:
            rec.systolic = int(data["systolic"])
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid systolic")), 400
        if not (50 <= rec.systolic <= 250):
            return jsonify(error("422", "Blood pressure out of range (50-250)")), 422
    if "diastolic" in data:
        try:
            rec.diastolic = int(data["diastolic"])
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid diastolic")), 400
        if not (50 <= rec.diastolic <= 250):
            return jsonify(error("422", "Blood pressure out of range (50-250)")), 422
    if "heart_rate" in data:
        try:
            rec.heart_rate = int(data["heart_rate"])
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid heart_rate")), 400
    if "tags" in data:
        tags = data.get("tags") or []
        if not isinstance(tags, list):
            return jsonify(error("400", "tags must be a list")), 400
        rec.tags = json.dumps(tags)
    if "note" in data:
        rec.note = data.get("note")
    manager.update(rec)
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
        "tags": json.loads(rec.tags) if rec.tags else [],
        "note": rec.note,
        # Timezone-aware UTC now, serialized with trailing 'Z'
        "updated_at": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
    }), 200


@health_bp.route("/<int:rec_id>", methods=["DELETE"])
@jwt_required()
def delete_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    # Clean up mapping
    from ..extensions import db
    RecordSubject.query.filter_by(record_id=rec.id).delete()
    manager.delete(rec)
    return jsonify({"message": "Record deleted successfully."}), 200
