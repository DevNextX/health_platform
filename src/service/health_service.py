"""
Health service endpoints. Generated by Zhuang
"""
import json
from datetime import datetime, UTC
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy import and_, select
from io import StringIO
from urllib.parse import quote
import csv
from ..manager.health_manager import HealthManager
from ..manager.member_manager import MemberManager
from ..models import RecordSubject, Member
from ..utils import get_pagination_params, make_pagination, error, validate_health_record_data

health_bp = Blueprint("health", __name__)
manager = HealthManager()
member_mgr = MemberManager()


@health_bp.route("", methods=["POST"])
@jwt_required()
def create_record():
    user_id = get_jwt_identity()
    data = request.get_json(force=True) or {}
    
    # Validate health record data using new validation rules. Generated by Copilot for issue #5
    is_valid, error_message = validate_health_record_data(data)
    if not is_valid:
        return jsonify(error("400", error_message)), 400
    
    # Extract validated values
    systolic = int(data.get("systolic"))
    diastolic = int(data.get("diastolic"))
    heart_rate = data.get("heart_rate")
    if heart_rate is not None:
        heart_rate = int(heart_rate)
    
    ts_raw = data.get("timestamp")
    # Use timezone-aware UTC datetime to avoid deprecation warnings
    ts = datetime.now(UTC) if not ts_raw else datetime.fromisoformat(ts_raw.replace("Z", "+00:00"))
    tags = data.get("tags") or []
    if not isinstance(tags, list):
        return jsonify(error("400", "tags must be a list")), 400
    note = data.get("note")

    # Determine subject member (default to self member if not provided)
    subject_member_id = data.get("subject_member_id")
    if subject_member_id is not None:
        try:
            subject_member_id = int(subject_member_id)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid subject_member_id")), 400
        # Validate member belongs to current user's household
        m = member_mgr.get_member(user_id, subject_member_id)
        if not m or m.status != "active":
            return jsonify(error("404", "Member not found")), 404
    else:
        m = member_mgr.get_or_create_self_member(user_id)
        subject_member_id = m.id

    rec = manager.create(user_id=user_id, systolic=systolic, diastolic=diastolic, heart_rate=heart_rate,
                         timestamp=ts, tags=tags, note=note)
    # Link record to subject
    rs = RecordSubject()
    hh = member_mgr.ensure_default_household(user_id)
    rs.record_id = rec.id
    rs.household_id = hh.id
    rs.member_id = subject_member_id
    rs.created_by_user_id = user_id
    from ..extensions import db
    db.session.add(rs)
    db.session.commit()
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
    # Normalize UTC offset to trailing 'Z' for clients
    "timestamp": rec.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": tags,
        "note": rec.note,
    "created_at": rec.created_at.isoformat().replace("+00:00", "Z"),
    "subject_member_id": subject_member_id,
    }), 201


@health_bp.route("", methods=["GET"])
@jwt_required()
def list_records():
    user_id = get_jwt_identity()
    page, size = get_pagination_params()
    # Build filters
    tags_q = request.args.get("tags")
    tag_list = None
    if tags_q:
        tag_list = [x.strip() for x in tags_q.split(",") if x.strip()]

    date_from = request.args.get("date_from")
    date_to = request.args.get("date_to")
    df = None
    dt = None
    if date_from:
        try:
            df = datetime.fromisoformat(date_from.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_from")), 400
    if date_to:
        try:
            dt = datetime.fromisoformat(date_to.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_to")), 400

    # Filter by member if provided
    subject_member_id = request.args.get("subject_member_id")
    # Generated by Zhuang: always resolve self_member for potential lazy backfill
    self_member = member_mgr.get_or_create_self_member(user_id)
    if subject_member_id is not None:
        try:
            subject_member_id = int(subject_member_id)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid subject_member_id")), 400
        # Validate membership
        m = member_mgr.get_member(user_id, subject_member_id)
        if not m:
            return jsonify(error("404", "Member not found")), 404
        # Generated by Zhuang: if explicitly filtering by Self, still perform lazy backfill
        if m.id == self_member.id:
            from ..models import HealthRecord
            from ..extensions import db
            subq = select(RecordSubject.record_id)
            unmapped = db.session.query(HealthRecord.id).\
                filter(HealthRecord.user_id == user_id).\
                filter(~HealthRecord.id.in_(subq)).all()
            if unmapped:
                hh = member_mgr.ensure_default_household(user_id)
                for (rid,) in unmapped:
                    rs = RecordSubject()
                    rs.record_id = rid
                    rs.household_id = hh.id
                    rs.member_id = self_member.id
                    rs.created_by_user_id = user_id
                    db.session.add(rs)
                db.session.commit()
    else:
        # Backfill legacy records to Self for this user lazily to ensure Self can see data
        # If no subject_member_id specified, do not filter, but ensure mappings exist for future Self queries
        from ..models import HealthRecord
        from ..extensions import db
        # Find records without mapping
        subq = select(RecordSubject.record_id)
        unmapped = db.session.query(HealthRecord.id).filter(HealthRecord.user_id == user_id).filter(
            ~HealthRecord.id.in_(subq)
        ).all()
        if unmapped:
            hh = member_mgr.ensure_default_household(user_id)
            for (rid,) in unmapped:
                rs = RecordSubject()
                rs.record_id = rid
                rs.household_id = hh.id
                rs.member_id = self_member.id
                rs.created_by_user_id = user_id
                db.session.add(rs)
            db.session.commit()

    total, items = manager.list(user_id=user_id, page=page, size=size, tags=tag_list, date_from=df, date_to=dt,
                                subject_member_id=subject_member_id)
    # Optionally include subject_member_id by querying mapping
    # To keep it lightweight, include only when a single member filter is active
    include_subject = subject_member_id is not None
    data = [{
        "id": r.id,
        "systolic": r.systolic,
        "diastolic": r.diastolic,
        "heart_rate": r.heart_rate,
    "timestamp": r.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": json.loads(r.tags) if r.tags else [],
        "note": r.note,
        **({"subject_member_id": subject_member_id} if include_subject else {}),
    } for r in items]
    return jsonify({"records": data, "pagination": make_pagination(page, size, total)}), 200


@health_bp.route("/export", methods=["GET"])
@jwt_required()
def export_csv():
    """Export health records as CSV. Filters: subject_member_id, date_from, date_to, tags. Generated by Zhuang"""
    user_id = get_jwt_identity()
    # Reuse parsing from list_records
    tags_q = request.args.get("tags")
    tag_list = None
    if tags_q:
        tag_list = [x.strip() for x in tags_q.split(",") if x.strip()]

    date_from = request.args.get("date_from")
    date_to = request.args.get("date_to")
    df = None
    dt = None
    if date_from:
        try:
            df = datetime.fromisoformat(date_from.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_from")), 400
    if date_to:
        try:
            dt = datetime.fromisoformat(date_to.replace("Z", "+00:00"))
        except ValueError:
            return jsonify(error("400", "Invalid date_to")), 400

    subject_member_id = request.args.get("subject_member_id")
    self_member = member_mgr.get_or_create_self_member(user_id)
    selected_member = None  # Generated by Zhuang
    if subject_member_id is not None:
        try:
            subject_member_id = int(subject_member_id)
        except (TypeError, ValueError):
            return jsonify(error("400", "Invalid subject_member_id")), 400
        m = member_mgr.get_member(user_id, subject_member_id)
        if not m:
            return jsonify(error("404", "Member not found")), 404
        selected_member = m
        # If exporting Self, ensure backfill so legacy records are included
        if m.id == self_member.id:
            from ..models import HealthRecord
            from ..extensions import db
            subq = select(RecordSubject.record_id)
            unmapped = db.session.query(HealthRecord.id).\
                filter(HealthRecord.user_id == user_id).\
                filter(~HealthRecord.id.in_(subq)).all()
            if unmapped:
                hh = member_mgr.ensure_default_household(user_id)
                for (rid,) in unmapped:
                    rs = RecordSubject()
                    rs.record_id = rid
                    rs.household_id = hh.id
                    rs.member_id = self_member.id
                    rs.created_by_user_id = user_id
                    db.session.add(rs)
                db.session.commit()
    else:
        # No filter means export all records for user; also perform backfill for Self in case client later filters
        from ..models import HealthRecord
        from ..extensions import db
        subq = select(RecordSubject.record_id)
        unmapped = db.session.query(HealthRecord.id).\
            filter(HealthRecord.user_id == user_id).\
            filter(~HealthRecord.id.in_(subq)).all()
        if unmapped:
            hh = member_mgr.ensure_default_household(user_id)
            for (rid,) in unmapped:
                rs = RecordSubject()
                rs.record_id = rid
                rs.household_id = hh.id
                rs.member_id = self_member.id
                rs.created_by_user_id = user_id
                db.session.add(rs)
            db.session.commit()

    # Fetch all records according to filter
    items = manager.list_all(user_id=user_id, tags=tag_list, date_from=df, date_to=dt, subject_member_id=subject_member_id)

    # Generated by Zhuang: build record_id -> member_name map for CSV output
    from ..extensions import db
    rec_ids = [r.id for r in items]
    name_map = {}
    if rec_ids:
        rows = db.session.query(RecordSubject.record_id, Member.full_name).\
            join(Member, Member.id == RecordSubject.member_id).\
            filter(RecordSubject.record_id.in_(rec_ids)).all()
        for rid, full_name in rows:
            name_map[rid] = full_name

    # Prepare CSV
    buf = StringIO()
    writer = csv.writer(buf)
    writer.writerow(["id", "member_name", "timestamp", "systolic", "diastolic", "heart_rate", "tags", "note"])
    for r in items:
        tags = json.loads(r.tags) if r.tags else []
        writer.writerow([
            r.id,
            name_map.get(r.id, (selected_member.full_name if selected_member else "")),
            r.timestamp.isoformat().replace("+00:00", "Z"),
            r.systolic,
            r.diastolic,
            r.heart_rate if r.heart_rate is not None else "",
            ";".join(tags),
            (r.note or '').replace('\n', ' ').strip(),
        ])
    # Build a meaningful filename including member name and optional date range; provide ASCII fallback and UTF-8 filename* for proper display
    if selected_member is not None:
        member_display = (selected_member.full_name or f"member-{selected_member.id}").strip()
        ascii_member = f"member_{selected_member.id}"
    else:
        member_display = "all"  # Generated by Zhuang
        ascii_member = "all"

    # Keep original display for UTF-8 filename*, but sanitize for safety in ASCII fallback
    # Generated by Zhuang: append date range suffix when provided via filters
    date_suffix = ""
    if df or dt:
        def _fmt_date(d):
            return d.date().isoformat()
        if df and dt:
            date_suffix = f"_{_fmt_date(df)}_{_fmt_date(dt)}"
        elif df:
            date_suffix = f"_{_fmt_date(df)}_to"
        else:
            date_suffix = f"_to_{_fmt_date(dt)}"

    filename_utf8 = f"health_records_{member_display}{date_suffix}.csv"
    ascii_fallback = f"health_records_{ascii_member}{date_suffix}.csv"
    # Prepend BOM to help Excel properly recognize UTF-8 for Chinese characters
    csv_data = '\ufeff' + buf.getvalue()

    from flask import Response
    return Response(
        csv_data,
        mimetype='text/csv; charset=utf-8',
        headers={
            # RFC 5987 for UTF-8 filename
            'Content-Disposition': f"attachment; filename=\"{ascii_fallback}\"; filename*=UTF-8''{quote(filename_utf8)}"
        }
    )


# Generated by Zhuang: Allow CORS preflight to pass with 2xx by handling OPTIONS without JWT
@health_bp.route("/export", methods=["OPTIONS"])
def export_csv_options():
    return "", 204


@health_bp.route("/<int:rec_id>", methods=["GET"])
@jwt_required()
def get_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
    "timestamp": rec.timestamp.isoformat().replace("+00:00", "Z"),
        "tags": json.loads(rec.tags) if rec.tags else [],
        "note": rec.note,
    "created_at": rec.created_at.isoformat().replace("+00:00", "Z"),
    }), 200


@health_bp.route("/<int:rec_id>", methods=["PUT"])
@jwt_required()
def update_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    data = request.get_json(force=True) or {}
    
    # Create a combined data dict for validation with existing values as defaults
    combined_data = {
        "systolic": data.get("systolic", rec.systolic),
        "diastolic": data.get("diastolic", rec.diastolic),
        "heart_rate": data.get("heart_rate", rec.heart_rate)
    }
    
    # Validate combined data using new validation rules. Generated by Copilot for issue #5
    is_valid, error_message = validate_health_record_data(combined_data)
    if not is_valid:
        return jsonify(error("400", error_message)), 400
    
    # Apply validated updates
    if "systolic" in data:
        rec.systolic = int(data["systolic"])
    if "diastolic" in data:
        rec.diastolic = int(data["diastolic"])
    if "heart_rate" in data:
        rec.heart_rate = int(data["heart_rate"]) if data["heart_rate"] is not None else None
    if "tags" in data:
        tags = data.get("tags") or []
        if not isinstance(tags, list):
            return jsonify(error("400", "tags must be a list")), 400
        rec.tags = json.dumps(tags)
    if "note" in data:
        rec.note = data.get("note")
    manager.update(rec)
    return jsonify({
        "id": rec.id,
        "systolic": rec.systolic,
        "diastolic": rec.diastolic,
        "heart_rate": rec.heart_rate,
        "tags": json.loads(rec.tags) if rec.tags else [],
        "note": rec.note,
        # Timezone-aware UTC now, serialized with trailing 'Z'
        "updated_at": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
    }), 200


@health_bp.route("/<int:rec_id>", methods=["DELETE"])
@jwt_required()
def delete_record(rec_id: int):
    user_id = get_jwt_identity()
    rec = manager.get(user_id=user_id, rec_id=rec_id)
    if not rec:
        return jsonify(error("404", "Record not found")), 404
    # Clean up mapping
    from ..extensions import db
    RecordSubject.query.filter_by(record_id=rec.id).delete()
    manager.delete(rec)
    return jsonify({"message": "Record deleted successfully."}), 200
