"""
Authorization decorators and utilities for role-based access control.
Generated by Copilot
"""
from functools import wraps
from typing import Optional, List, Union, Tuple
from flask import jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity, get_jwt
from ..manager.user_manager import UserManager
from ..utils import error


def require_roles(*allowed_roles: str):
    """
    Decorator to require specific roles for accessing endpoints.
    
    Args:
        *allowed_roles: One or more roles that are allowed to access the endpoint
                       (e.g., "ADMIN", "SUPER_ADMIN")
    
    Usage:
        @require_roles("ADMIN", "SUPER_ADMIN")
        def admin_function():
            pass
    """
    def decorator(f):
        @wraps(f)
        @jwt_required()
        def decorated_function(*args, **kwargs):
            # Get current user
            user_manager = UserManager()
            identity = get_jwt_identity()
            claims = get_jwt()
            
            # Validate JWT
            user = user_manager.get_user(identity)
            if not user:
                return jsonify(error("401", "Invalid token")), 401
            
            # Check token version to handle logout-all
            if claims.get("token_version") != user.token_version:
                return jsonify(error("401", "Token revoked")), 401
            
            # Check if user must change password
            if user.must_change_password and f.__name__ not in ["change_password", "logout"]:
                return jsonify(error("403", "Password change required", {"code": "PASSWORD_CHANGE_REQUIRED"})), 403
            
            # Check role authorization
            if user.role not in allowed_roles:
                return jsonify(error("403", "Insufficient permissions")), 403
            
            # Add user to kwargs for convenience
            kwargs['current_user'] = user
            return f(*args, **kwargs)
        
        return decorated_function
    return decorator


def require_admin(f):
    """Decorator to require ADMIN or SUPER_ADMIN role"""
    return require_roles("ADMIN", "SUPER_ADMIN")(f)


def require_super_admin(f):
    """Decorator to require SUPER_ADMIN role only"""
    return require_roles("SUPER_ADMIN")(f)


def get_current_user_role() -> Optional[str]:
    """Get the role of the current JWT user without requiring specific permissions"""
    try:
        user_manager = UserManager()
        identity = get_jwt_identity()
        
        if not identity:
            return None
            
        user = user_manager.get_user(identity)
        return user.role if user else None
    except:
        return None


def is_super_admin() -> bool:
    """Check if current user is super admin"""
    return get_current_user_role() == "SUPER_ADMIN"


def is_admin_or_higher() -> bool:
    """Check if current user is admin or super admin"""
    role = get_current_user_role()
    return role in ("ADMIN", "SUPER_ADMIN")


def validate_role_change(current_user_role: str, target_user_role: str, new_role: str) -> Tuple[bool, str]:
    """
    Validate if a role change is allowed based on business rules.
    
    Args:
        current_user_role: Role of the user making the change
        target_user_role: Current role of the user being changed
        new_role: New role to assign
    
    Returns:
        Tuple of (is_valid, error_message)
    """
    valid_roles = {"USER", "ADMIN", "SUPER_ADMIN"}
    
    # Validate new role is valid
    if new_role not in valid_roles:
        return False, "Invalid role"
    
    # Only SUPER_ADMIN can change roles
    if current_user_role != "SUPER_ADMIN":
        return False, "Only super admin can change user roles"
    
    # Cannot change SUPER_ADMIN role (protection)
    if target_user_role == "SUPER_ADMIN":
        return False, "Cannot modify super admin role"
    
    # Cannot create new SUPER_ADMIN (uniqueness)
    if new_role == "SUPER_ADMIN":
        return False, "Cannot create additional super admin"
    
    # Valid role changes: USER <-> ADMIN (by SUPER_ADMIN only)
    if new_role in {"USER", "ADMIN"}:
        return True, ""
    
    return False, "Invalid role change"


class RoleChecker:
    """Utility class for checking user roles and permissions"""
    
    def __init__(self, user_manager: Optional[UserManager] = None):
        self.user_manager = user_manager or UserManager()
    
    def can_view_users(self, user_role: str) -> bool:
        """Check if user can view user list"""
        return user_role in ("ADMIN", "SUPER_ADMIN")
    
    def can_change_roles(self, user_role: str) -> bool:
        """Check if user can change other users' roles"""
        return user_role == "SUPER_ADMIN"
    
    def can_reset_password(self, user_role: str, target_role: str) -> bool:
        """Check if user can reset another user's password"""
        if user_role == "SUPER_ADMIN":
            return target_role != "SUPER_ADMIN"  # Cannot reset super admin password
        elif user_role == "ADMIN":
            return target_role in ("USER", "ADMIN")  # Admin can reset USER and ADMIN
        else:
            return False  # USER cannot reset passwords
    
    def get_viewable_users_filter(self, user_role: str) -> dict:
        """Get filter criteria for users that current role can view"""
        if user_role == "SUPER_ADMIN":
            return {}  # Can view all users
        elif user_role == "ADMIN":
            return {"role": ["USER", "ADMIN"]}  # Cannot view SUPER_ADMIN
        else:
            return {"id": -1}  # USER cannot view any users (empty result)