# Branch-Environment Strategy Best Practices
# Generated by Zhuang

## Overview
This document outlines the best practices for managing branches, environments, and CI/CD configurations for the Health Platform project.

## Current Architecture Analysis

### 1. Single Workflow Strategy (Current Implementation)
Currently using one GitHub Actions workflow (`.github/workflows/ci.yml`) that handles multiple environments through:
- Branch-based automatic deployment
- Manual workflow dispatch with environment selection
- Environment-specific configuration files

**Advantages:**
- Single workflow to maintain
- Consistent deployment process across environments
- Easy to understand and debug

**Disadvantages:**
- All environments share the same workflow complexity
- Security context mixing (all secrets accessible to all environments)
- Harder to implement environment-specific approval workflows

## Best Practice Strategies

### Strategy 1: Branch-Based Single Workflow (Recommended for Small-Medium Teams)

#### Branch-Environment Mapping:
- `main` → Production Environment
- `staging` → Staging Environment  
- `develop` → Development Environment
- Feature branches → No automatic deployment (manual only)

#### Configuration Structure:
```
.github/workflows/
├── ci-cd.yml                 # Main workflow
├── pr-validation.yml         # PR checks only

deploy/config/
├── dev.env                   # Development configuration
├── staging.env               # Staging configuration
└── prod.env                  # Production configuration
```

#### Workflow Example:
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, staging, develop]
  pull_request:
    branches: [main, staging, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        type: choice
        options: [dev, staging, prod]

jobs:
  # Environment detection logic
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
    steps:
      - id: env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi
```

### Strategy 2: Multiple Workflow Strategy (Recommended for Large Teams)

#### Separate workflows for each environment:
```
.github/workflows/
├── deploy-dev.yml            # Development deployment
├── deploy-staging.yml        # Staging deployment
├── deploy-prod.yml           # Production deployment
├── build.yml                 # Build and test only
└── pr-validation.yml         # PR checks
```

#### Benefits:
- Environment isolation
- Different approval processes per environment
- Environment-specific secrets scope
- Independent deployment schedules

#### Example Structure:

**deploy-dev.yml:**
```yaml
name: Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:

environment:
  name: development
  url: https://dev.health-platform.example.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to Dev
        env:
          ENVIRONMENT: dev
          KUBE_CONFIG: ${{ secrets.DEV_KUBE_CONFIG }}
          KUBE_CONTEXT: ${{ secrets.DEV_KUBE_CONTEXT }}
        run: |
          source deploy/config/dev.env
          ./deploy/deploy-configurable.sh
```

**deploy-prod.yml:**
```yaml
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

environment:
  name: production
  url: https://health-platform.example.com

jobs:
  deploy:
    runs-on: ubuntu-latest
    needs: approval  # Require manual approval
    environment: production
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to Production
        env:
          ENVIRONMENT: prod
          KUBE_CONFIG: ${{ secrets.PROD_KUBE_CONFIG }}
          KUBE_CONTEXT: ${{ secrets.PROD_KUBE_CONTEXT }}
        run: |
          source deploy/config/prod.env
          ./deploy/deploy-configurable.sh
```

## Recommended Branch Strategy

### Git Flow with Environment Branches:
```
main (production-ready)
  ↑
staging (pre-production testing)
  ↑
develop (integration branch)
  ↑
feature/* (feature development)
```

### Deployment Flow:
1. **Feature Development**: `feature/xxx` → `develop`
2. **Integration Testing**: `develop` → Auto-deploy to Dev environment
3. **Pre-production**: `develop` → `staging` → Auto-deploy to Staging
4. **Production**: `staging` → `main` → Auto-deploy to Production (with approval)

## Environment Configuration Best Practices

### 1. Environment-Specific Secrets
```
GitHub Secrets by Environment:
- DEV_KUBE_CONFIG / DEV_KUBE_CONTEXT
- STAGING_KUBE_CONFIG / STAGING_KUBE_CONTEXT  
- PROD_KUBE_CONFIG / PROD_KUBE_CONTEXT
```

### 2. Configuration File Hierarchy
```
deploy/config/
├── common.env              # Shared configurations
├── dev.env                 # Development overrides
├── staging.env             # Staging overrides
└── prod.env                # Production overrides
```

### 3. Security Considerations
- Never commit sensitive data to configuration files
- Use GitHub Environments for approval workflows
- Implement least privilege access for each environment
- Separate container registries or namespaces per environment

## Implementation Recommendations

### For Current Project (Health Platform):

**Immediate Actions:**
1. Create `staging` and `develop` branches
2. Implement environment detection in current workflow
3. Add staging-specific secrets to GitHub

**Medium-term:**
1. Split into multiple workflows if team grows
2. Add manual approval for production deployments
3. Implement automated testing gates

**Long-term:**
1. Consider GitOps with ArgoCD for advanced scenarios
2. Implement infrastructure as code with Terraform
3. Add monitoring and alerting per environment

## Migration Plan

### Phase 1: Branch Creation (Week 1)
```bash
# Create and configure branches
git checkout main
git checkout -b staging
git push origin staging

git checkout -b develop
git push origin develop
```

### Phase 2: Workflow Enhancement (Week 2)
- Update current workflow for branch-based deployment
- Add environment detection logic
- Configure GitHub Secrets per environment

### Phase 3: Testing and Validation (Week 3)
- Test deployments on all environments
- Validate configuration isolation
- Document deployment procedures

### Phase 4: Advanced Features (Week 4+)
- Add manual approval workflows
- Implement blue-green or canary deployments
- Add monitoring and rollback capabilities

## Examples for Common Scenarios

### Scenario 1: Hotfix Deployment
```
main (prod issue detected)
  ↓
hotfix/critical-bug-fix
  ↓
main (after testing) → Immediate prod deployment
  ↓
staging ← merge back
  ↓  
develop ← merge back
```

### Scenario 2: Feature Development
```
develop
  ↓
feature/new-dashboard → Develop locally, no auto-deploy
  ↓
develop (PR merged) → Auto-deploy to dev
  ↓
staging (after testing) → Auto-deploy to staging  
  ↓
main (after approval) → Auto-deploy to prod
```

## Monitoring and Observability

### Per-Environment Monitoring:
- Separate Grafana dashboards
- Environment-specific alerts
- Performance baseline per environment
- Cost monitoring per namespace/environment

This strategy provides flexibility while maintaining simplicity and can evolve with team and project needs.
